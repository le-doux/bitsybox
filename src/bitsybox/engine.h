#ifndef ENGINE_H
#define ENGINE_H

char* script_js =
	"function Script() {\n"
	"\n"
	"this.CreateInterpreter = function() {\n"
	"	return new Interpreter();\n"
	"};\n"
	"\n"
	"this.CreateUtils = function() {\n"
	"	return new Utils();\n"
	"};\n"
	"\n"
	"var Interpreter = function() {\n"
	"	var env = new Environment();\n"
	"	var parser = new Parser( env );\n"
	"\n"
	"	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };\n"
	"\n"
	"	// TODO -- maybe this should return a string instead othe actual script??\n"
	"	this.Compile = function(scriptName, scriptStr) {\n"
	"		var script = parser.Parse(scriptStr, scriptName);\n"
	"		env.SetScript(scriptName, script);\n"
	"	}\n"
	"	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script\n"
	"		var localEnv = new LocalEnvironment(env);\n"
	"\n"
	"		if (objectContext) {\n"
	"			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?\n"
	"		}\n"
	"\n"
	"		var script = env.GetScript(scriptName);\n"
	"\n"
	"		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );\n"
	"	}\n"
	"	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately\n"
	"		// bitsy.log(\"INTERPRET\");\n"
	"		var localEnv = new LocalEnvironment(env);\n"
	"\n"
	"		if (objectContext) {\n"
	"			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?\n"
	"		}\n"
	"\n"
	"		var script = parser.Parse(scriptStr, \"anonymous\");\n"
	"		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );\n"
	"	}\n"
	"	this.HasScript = function(name) { return env.HasScript(name); };\n"
	"\n"
	"	this.ResetEnvironment = function() {\n"
	"		env = new Environment();\n"
	"		parser = new Parser( env );\n"
	"	}\n"
	"\n"
	"	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it\n"
	"		return parser.Parse(scriptStr, rootId);\n"
	"	}\n"
	"\n"
	"	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally\n"
	"		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?\n"
	"		scriptTree.Eval(\n"
	"			localEnv,\n"
	"			function(result) {\n"
	"				OnScriptReturn(result, exitHandler);\n"
	"			});\n"
	"	}\n"
	"\n"
	"	function OnScriptReturn(result, exitHandler) {\n"
	"		if (exitHandler != null) {\n"
	"			exitHandler(result);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.CreateExpression = function(expStr) {\n"
	"		return parser.CreateExpression(expStr);\n"
	"	}\n"
	"\n"
	"	this.SetVariable = function(name,value,useHandler) {\n"
	"		env.SetVariable(name,value,useHandler);\n"
	"	}\n"
	"\n"
	"	this.DeleteVariable = function(name,useHandler) {\n"
	"		env.DeleteVariable(name,useHandler);\n"
	"	}\n"
	"	this.HasVariable = function(name) {\n"
	"		return env.HasVariable(name);\n"
	"	}\n"
	"\n"
	"	this.SetOnVariableChangeHandler = function(onVariableChange) {\n"
	"		env.SetOnVariableChangeHandler(onVariableChange);\n"
	"	}\n"
	"	this.GetVariableNames = function() {\n"
	"		return env.GetVariableNames();\n"
	"	}\n"
	"	this.GetVariable = function(name) {\n"
	"		return env.GetVariable(name);\n"
	"	}\n"
	"\n"
	"	function DebugVisualizeScriptTree(scriptTree) {\n"
	"		var printVisitor = {\n"
	"			Visit : function(node,depth) {\n"
	"				bitsy.log(\"-\".repeat(depth) + \"- \" + node.ToString());\n"
	"			},\n"
	"		};\n"
	"\n"
	"		scriptTree.VisitAll( printVisitor );\n"
	"	}\n"
	"\n"
	"	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;\n"
	"\n"
	"	this.DebugVisualizeScript = function(scriptName) {\n"
	"		DebugVisualizeScriptTree(env.GetScript(scriptName));\n"
	"	}\n"
	"}\n"
	"\n"
	"\n"
	"var Utils = function() {\n"
	"	// for editor ui\n"
	"	this.CreateDialogBlock = function(children,doIndentFirstLine) {\n"
	"		if (doIndentFirstLine === undefined) {\n"
	"			doIndentFirstLine = true;\n"
	"		}\n"
	"\n"
	"		var block = new DialogBlockNode(doIndentFirstLine);\n"
	"\n"
	"		for (var i = 0; i < children.length; i++) {\n"
	"			block.AddChild(children[i]);\n"
	"		}\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateOptionBlock = function() {\n"
	"		var block = new DialogBlockNode(false);\n"
	"		block.AddChild(new FuncNode(\"say\", [new LiteralNode(\" \")]));\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateItemConditionPair = function() {\n"
	"		var itemFunc = this.CreateFunctionBlock(\"item\", [\"0\"]);\n"
	"		var condition = new ExpNode(\"==\", itemFunc, new LiteralNode(1));\n"
	"		var result = new DialogBlockNode(true);\n"
	"		result.AddChild(new FuncNode(\"say\", [new LiteralNode(\" \")]));\n"
	"		var conditionPair = new ConditionPairNode(condition, result);\n"
	"		return conditionPair;\n"
	"	}\n"
	"\n"
	"	this.CreateVariableConditionPair = function() {\n"
	"		var varNode = this.CreateVariableNode(\"a\");\n"
	"		var condition = new ExpNode(\"==\", varNode, new LiteralNode(1));\n"
	"		var result = new DialogBlockNode(true);\n"
	"		result.AddChild(new FuncNode(\"say\", [new LiteralNode(\" \")]));\n"
	"		var conditionPair = new ConditionPairNode(condition, result);\n"
	"		return conditionPair;\n"
	"	}\n"
	"\n"
	"	this.CreateDefaultConditionPair = function() {\n"
	"		var condition = this.CreateElseNode();\n"
	"		var result = new DialogBlockNode(true);\n"
	"		result.AddChild(new FuncNode(\"say\", [new LiteralNode(\" \")]));\n"
	"		var conditionPair = new ConditionPairNode(condition, result);\n"
	"		return conditionPair;\n"
	"	}\n"
	"\n"
	"	this.CreateEmptySayFunc = function() {\n"
	"		return new FuncNode(\"say\", [new LiteralNode(\"...\")]);\n"
	"	}\n"
	"\n"
	"	this.CreateFunctionBlock = function(name, initParamValues) {\n"
	"		var parameters = [];\n"
	"		for (var i = 0; i < initParamValues.length; i++) {\n"
	"			parameters.push(new LiteralNode(initParamValues[i]));\n"
	"		}\n"
	"\n"
	"		var node = new FuncNode(name, parameters);\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild(node);\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	// TODO : rename ParseStringToLiteralNode?\n"
	"	this.CreateLiteralNode = function(str) {\n"
	"		if (str === \"true\") {\n"
	"			return new LiteralNode(true);\n"
	"		}\n"
	"		else if (str === \"false\") {\n"
	"			return new LiteralNode(false);\n"
	"		}\n"
	"		else if (!isNaN(parseFloat(str))) {\n"
	"			return new LiteralNode(parseFloat(str));\n"
	"		}\n"
	"		else {\n"
	"			return new LiteralNode(str);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.CreateVariableNode = function(variableName) {\n"
	"		return new VarNode(variableName);\n"
	"	}\n"
	"\n"
	"	this.CreatePropertyNode = function(propertyName, literalValue) {\n"
	"		var varNode = new VarNode(propertyName);\n"
	"		var valNode = new LiteralNode(literalValue);\n"
	"		var node = new FuncNode(\"property\", [varNode, valNode]);\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild(node);\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateElseNode = function() {\n"
	"		return new ElseNode();\n"
	"	}\n"
	"\n"
	"	this.CreateStringLiteralNode = function(str) {\n"
	"		return new LiteralNode(str);\n"
	"	}\n"
	"\n"
	"	// TODO : need to split up code & dialog blocks :|\n"
	"	this.CreateCodeBlock = function() {\n"
	"		return new CodeBlockNode();\n"
	"	}\n"
	"\n"
	"	this.ChangeSequenceType = function(oldSequence, type) {\n"
	"		if(type === \"sequence\") {\n"
	"			return new SequenceNode(oldSequence.children);\n"
	"		}\n"
	"		else if(type === \"cycle\") {\n"
	"			return new CycleNode(oldSequence.children);\n"
	"		}\n"
	"		else if(type === \"shuffle\") {\n"
	"			return new ShuffleNode(oldSequence.children);\n"
	"		}\n"
	"		return oldSequence;\n"
	"	}\n"
	"\n"
	"	this.CreateSequenceBlock = function() {\n"
	"		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option1.AddChild(new FuncNode(\"say\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option2.AddChild(new FuncNode(\"say\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var sequence = new SequenceNode( [ option1, option2 ] );\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild( sequence );\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateCycleBlock = function() {\n"
	"		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option1.AddChild(new FuncNode(\"say\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option2.AddChild(new FuncNode(\"say\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var sequence = new CycleNode( [ option1, option2 ] );\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild( sequence );\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateShuffleBlock = function() {\n"
	"		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option1.AddChild(new FuncNode(\"say\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );\n"
	"		option2.AddChild(new FuncNode(\"say\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var sequence = new ShuffleNode( [ option1, option2 ] );\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild( sequence );\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.CreateIfBlock = function() {\n"
	"		var leftNode = new CodeBlockNode();\n"
	"		leftNode.AddChild( new FuncNode(\"item\", [new LiteralNode(\"0\")] ) );\n"
	"		var rightNode = new LiteralNode( 1 );\n"
	"		var condition1 = new ExpNode(\"==\", leftNode, rightNode );\n"
	"\n"
	"		var condition2 = new ElseNode();\n"
	"\n"
	"		var result1 = new DialogBlockNode();\n"
	"		result1.AddChild(new FuncNode(\"say\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var result2 = new DialogBlockNode();\n"
	"		result2.AddChild(new FuncNode(\"say\", [new LiteralNode(\"...\")]));\n"
	"\n"
	"		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );\n"
	"		var block = new CodeBlockNode();\n"
	"		block.AddChild( ifNode );\n"
	"		return block;\n"
	"	}\n"
	"\n"
	"	this.ReadDialogScript = function(lines, i) {\n"
	"		var scriptStr = \"\";\n"
	"		if (lines[i] === Sym.DialogOpen) {\n"
	"			scriptStr += lines[i] + \"\\n\";\n"
	"			i++;\n"
	"			while(lines[i] != Sym.DialogClose) {\n"
	"				scriptStr += lines[i] + \"\\n\";\n"
	"				i++;\n"
	"			}\n"
	"			scriptStr += lines[i];\n"
	"			i++;\n"
	"		}\n"
	"		else {\n"
	"			scriptStr += lines[i];\n"
	"			i++;\n"
	"		}\n"
	"		return { script:scriptStr, index:i };\n"
	"	}\n"
	"\n"
	"	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript\n"
	"\n"
	"	this.EnsureDialogBlockFormat = function(dialogStr) {\n"
	"		// TODO -- what if it's already enclosed in dialog symbols??\n"
	"		if(dialogStr.indexOf('\\n') > -1) {\n"
	"			dialogStr = Sym.DialogOpen + \"\\n\" + dialogStr + \"\\n\" + Sym.DialogClose;\n"
	"		}\n"
	"		return dialogStr;\n"
	"	}\n"
	"\n"
	"	this.RemoveDialogBlockFormat = function(source) {\n"
	"		var sourceLines = source.split(\"\\n\");\n"
	"		var dialogStr = \"\";\n"
	"		if(sourceLines[0] === Sym.DialogOpen) {\n"
	"			// multi line\n"
	"			var i = 1;\n"
	"			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {\n"
	"				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\\n' : '');\n"
	"				i++;\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			// single line\n"
	"			dialogStr = source;\n"
	"		}\n"
	"		return dialogStr;\n"
	"	}\n"
	"\n"
	"	this.SerializeDialogNodeList = function(nodeList) {\n"
	"		var tempBlock = new DialogBlockNode(false);\n"
	"		 // set children directly to avoid breaking the parenting chain for this temp operation\n"
	"		tempBlock.children = nodeList;\n"
	"		return tempBlock.Serialize();\n"
	"	}\n"
	"\n"
	"	this.GetOperatorList = function() {\n"
	"		return [Sym.Set].concat(Sym.Operators);\n"
	"	}\n"
	"\n"
	"	this.IsInlineCode = function(node) {\n"
	"		return isInlineCode(node);\n"
	"	}\n"
	"}\n"
	"\n"
	"\n"
	"/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?\n"
	"function deprecatedFunc(environment,parameters,onReturn) {\n"
	"	bitsy.log(\"BITSY SCRIPT WARNING: Tried to use deprecated function\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function sayFunc(environment, parameters, onReturn) {\n"
	"	if (parameters[0] != undefined && parameters[0] != null) {\n"
	"		var textStr = \"\" + parameters[0];\n"
	"		environment.GetDialogBuffer().AddText(textStr);\n"
	"		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });\n"
	"	}\n"
	"	else {\n"
	"		onReturn(null);\n"
	"	}\n"
	"}\n"
	"\n"
	"function linebreakFunc(environment, parameters, onReturn) {\n"
	"	// bitsy.log(\"LINEBREAK FUNC\");\n"
	"	environment.GetDialogBuffer().AddLinebreak();\n"
	"	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });\n"
	"}\n"
	"\n"
	"function pagebreakFunc(environment, parameters, onReturn) {\n"
	"	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });\n"
	"}\n"
	"\n"
	"function drawFunc(environment, parameters, onReturn) {\n"
	"	var drawingId = parameters[0];\n"
	"	environment.GetDialogBuffer().AddDrawing(drawingId);\n"
	"	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });\n"
	"}\n"
	"\n"
	"function drawSpriteFunc(environment, parameters, onReturn) {\n"
	"	var spriteId = parameters[0];\n"
	"\n"
	"	// check if id parameter is actually a name\n"
	"	if (names.sprite[spriteId] != undefined) {\n"
	"		spriteId = names.sprite[spriteId];\n"
	"	}\n"
	"\n"
	"	var drawingId = sprite[spriteId].drw;\n"
	"	drawFunc(environment, [drawingId], onReturn);\n"
	"}\n"
	"\n"
	"function drawTileFunc(environment, parameters, onReturn) {\n"
	"	var tileId = parameters[0];\n"
	"\n"
	"	// check if id parameter is actually a name\n"
	"	if (names.tile[tileId] != undefined) {\n"
	"		tileId = names.tile[tileId];\n"
	"	}\n"
	"\n"
	"	var drawingId = tile[tileId].drw;\n"
	"	drawFunc(environment, [drawingId], onReturn);\n"
	"}\n"
	"\n"
	"function drawItemFunc(environment, parameters, onReturn) {\n"
	"	var itemId = parameters[0];\n"
	"\n"
	"	// check if id parameter is actually a name\n"
	"	if (names.item[itemId] != undefined) {\n"
	"		itemId = names.item[itemId];\n"
	"	}\n"
	"\n"
	"	var drawingId = item[itemId].drw;\n"
	"	drawFunc(environment, [drawingId], onReturn);\n"
	"}\n"
	"\n"
	"function printFontFunc(environment, parameters, onReturn) {\n"
	"	var allCharacters = \"\";\n"
	"	var font = fontManager.Get(fontName);\n"
	"	var codeList = font.allCharCodes();\n"
	"	for (var i = 0; i < codeList.length; i++) {\n"
	"		allCharacters += String.fromCharCode(codeList[i]) + \" \";\n"
	"	}\n"
	"	sayFunc(environment, [allCharacters], onReturn);\n"
	"}\n"
	"\n"
	"function itemFunc(environment,parameters,onReturn) {\n"
	"	var itemId = parameters[0];\n"
	"\n"
	"	if (names.item[itemId] != undefined) {\n"
	"		// id is actually a name\n"
	"		itemId = names.item[itemId];\n"
	"	}\n"
	"\n"
	"	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;\n"
	"\n"
	"	if (parameters.length > 1) {\n"
	"		// TODO : is it a good idea to force inventory to be >= 0?\n"
	"		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));\n"
	"		curItemCount = player().inventory[itemId];\n"
	"\n"
	"		if (onInventoryChanged != null) {\n"
	"			onInventoryChanged(itemId);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	onReturn(curItemCount);\n"
	"}\n"
	"\n"
	"function toggleTextEffect(environment, name) {\n"
	"	if (environment.GetDialogBuffer().hasTextEffect(name)) {\n"
	"		environment.GetDialogBuffer().popTextEffect(name);\n"
	"	}\n"
	"	else {\n"
	"		environment.GetDialogBuffer().pushTextEffect(name, []);\n"
	"	}\n"
	"}\n"
	"\n"
	"function color1Func(environment, parameters, onReturn) {\n"
	"	toggleTextEffect(environment, \"clr1\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function color2Func(environment, parameters, onReturn) {\n"
	"	toggleTextEffect(environment, \"clr2\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function color3Func(environment, parameters, onReturn) {\n"
	"	toggleTextEffect(environment, \"clr3\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function colorFunc(environment, parameters, onReturn) {\n"
	"	environment.GetDialogBuffer().pushTextEffect(\"clr\", parameters);\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function colorPopFunc(environment, parameters, onReturn) {\n"
	"	if (environment.GetDialogBuffer().hasTextEffect(\"clr\")) {\n"
	"		environment.GetDialogBuffer().popTextEffect(\"clr\");\n"
	"	}\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function rainbowFunc(environment, parameters, onReturn) {\n"
	"	toggleTextEffect(environment, \"rbw\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function rainbowPopFunc(environment, parameters, onReturn) {\n"
	"	if (environment.GetDialogBuffer().hasTextEffect(\"rbw\")) {\n"
	"		environment.GetDialogBuffer().popTextEffect(\"rbw\");\n"
	"	}\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function wavyFunc(environment, parameters, onReturn) {\n"
	"	toggleTextEffect(environment, \"wvy\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function wavyPopFunc(environment, parameters, onReturn) {\n"
	"	if (environment.GetDialogBuffer().hasTextEffect(\"wvy\")) {\n"
	"		environment.GetDialogBuffer().popTextEffect(\"wvy\");\n"
	"	}\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function shakyFunc(environment, parameters, onReturn) {\n"
	"	toggleTextEffect(environment, \"shk\");\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function shakyPopFunc(environment, parameters, onReturn) {\n"
	"	if (environment.GetDialogBuffer().hasTextEffect(\"shk\")) {\n"
	"		environment.GetDialogBuffer().popTextEffect(\"shk\");\n"
	"	}\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function propertyFunc(environment, parameters, onReturn) {\n"
	"	var outValue = null;\n"
	"\n"
	"	if (parameters.length > 0 && parameters[0]) {\n"
	"		var propertyName = parameters[0];\n"
	"\n"
	"		if (environment.HasProperty(propertyName)) {\n"
	"			// TODO : in a future update I can handle the case of initializing a new property\n"
	"			// after which we can move this block outside the HasProperty check\n"
	"			if (parameters.length > 1) {\n"
	"				var inValue = parameters[1];\n"
	"				environment.SetProperty(propertyName, inValue);\n"
	"			}\n"
	"\n"
	"			outValue = environment.GetProperty(propertyName);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	bitsy.log(\"PROPERTY! \" + propertyName + \" \" + outValue);\n"
	"\n"
	"	onReturn(outValue);\n"
	"}\n"
	"\n"
	"function endFunc(environment,parameters,onReturn) {\n"
	"	isEnding = true;\n"
	"	isNarrating = true;\n"
	"	dialogRenderer.SetCentered(true);\n"
	"	dialogRenderer.DrawTextbox();\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function exitFunc(environment, parameters, onReturn) {\n"
	"	var destRoom;\n"
	"	var destX;\n"
	"	var destY;\n"
	"\n"
	"	if (parameters.length >= 1) {\n"
	"		destRoom = parameters[0];\n"
	"\n"
	"		// is it a name?\n"
	"		if (names.room[destRoom] != undefined) {\n"
	"			destRoom = names.room[destRoom];\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if (parameters.length >= 3) {\n"
	"		destX = parseInt(parameters[1]);\n"
	"		destY = parseInt(parameters[2]);\n"
	"	}\n"
	"\n"
	"	if (parameters.length >= 4) {\n"
	"		var transitionEffect = parameters[3];\n"
	"\n"
	"		transition.BeginTransition(\n"
	"			player().room,\n"
	"			player().x,\n"
	"			player().y,\n"
	"			destRoom,\n"
	"			destX,\n"
	"			destY,\n"
	"			transitionEffect);\n"
	"		transition.UpdateTransition(0);\n"
	"	}\n"
	"\n"
	"	var movePlayerAndResumeScript = function() {\n"
	"		if (destRoom != undefined && destX != undefined && destY != undefined) {\n"
	"			// update world state\n"
	"			player().room = destRoom;\n"
	"			player().x = destX;\n"
	"			player().y = destY;\n"
	"			state.room = destRoom;\n"
	"\n"
	"			// update game state\n"
	"			initRoom(state.room);\n"
	"		}\n"
	"\n"
	"		if (dialogRenderer) {\n"
	"			dialogRenderer.updateTextboxPosition();\n"
	"		}\n"
	"\n"
	"		// resume dialog script\n"
	"		onReturn(state.room);\n"
	"	};\n"
	"\n"
	"	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!\n"
	"	if (transition.IsTransitionActive()) {\n"
	"		transition.OnTransitionComplete(movePlayerAndResumeScript);\n"
	"	}\n"
	"	else {\n"
	"		movePlayerAndResumeScript();\n"
	"	}\n"
	"}\n"
	"\n"
	"function tuneFunc(environment, parameters, onReturn) {\n"
	"	if (parameters.length > 0) {\n"
	"		var tuneId = parameters[0];\n"
	"\n"
	"		// check if id parameter is actually a name\n"
	"		if (names.tune[tuneId] != undefined) {\n"
	"			tuneId = names.tune[tuneId];\n"
	"		}\n"
	"\n"
	"		if (soundPlayer) {\n"
	"			if (tuneId === \"0\") {\n"
	"				soundPlayer.stopTune();\n"
	"			}\n"
	"			else if (state.tune != tuneId) {\n"
	"				soundPlayer.playTune(tune[tuneId]);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		state.tune = tuneId;\n"
	"	}\n"
	"\n"
	"	onReturn(state.tune);\n"
	"}\n"
	"\n"
	"function blipFunc(environment, parameters, onReturn) {\n"
	"	if (parameters.length > 0) {\n"
	"		var blipId = parameters[0];\n"
	"\n"
	"		// check if id parameter is actually a name\n"
	"		if (names.blip[blipId] != undefined) {\n"
	"			blipId = names.blip[blipId];\n"
	"		}\n"
	"\n"
	"		soundPlayer.playBlip(blip[blipId]);\n"
	"	}\n"
	"\n"
	"	// if a dialog skip is happening, stop it and force a redraw of the textbox\n"
	"	if (dialogBuffer) {\n"
	"		if (dialogBuffer.tryInterruptSkip()) {\n"
	"			dialogRenderer.Draw(dialogBuffer, 0, true /* disableOnPrint */);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"/*\n"
	"// TODO : use later?\n"
	"function yakFunc(environment, parameters, onReturn) {\n"
	"	if (parameters.length > 0) {\n"
	"		var blipId = parameters[0];\n"
	"\n"
	"		// check if id parameter is actually a name\n"
	"		if (names.blip[blipId] != undefined) {\n"
	"			blipId = names.blip[blipId];\n"
	"		}\n"
	"\n"
	"		environment.GetDialogBuffer().pushTextEffect(\"yak\", [blipId]);\n"
	"	}\n"
	"\n"
	"	onReturn(null);\n"
	"}\n"
	"\n"
	"function yakPopFunc(environment, parameters, onReturn) {\n"
	"	if (environment.GetDialogBuffer().hasTextEffect(\"yak\")) {\n"
	"		environment.GetDialogBuffer().popTextEffect(\"yak\");\n"
	"	}\n"
	"\n"
	"	onReturn(null);\n"
	"}\n"
	"*/\n"
	"\n"
	"function paletteFunc(environment, parameters, onReturn) {\n"
	"	if (parameters.length > 0) {\n"
	"		var palId = parameters[0];\n"
	"\n"
	"		// check if id parameter is actually a name\n"
	"		if (names.palette[palId] != undefined) {\n"
	"			palId = names.palette[palId];\n"
	"		}\n"
	"\n"
	"		updatePalette(palId);\n"
	"	}\n"
	"\n"
	"	onReturn(state.pal);\n"
	"}\n"
	"\n"
	"function avatarFunc(environment, parameters, onReturn) {\n"
	"	if (parameters.length > 0) {\n"
	"		var sprId = parameters[0];\n"
	"\n"
	"		// check if id parameter is actually a name\n"
	"		if (names.sprite[sprId] != undefined) {\n"
	"			sprId = names.sprite[sprId];\n"
	"		}\n"
	"\n"
	"		// override the avatar's current appearance\n"
	"		state.ava = sprId;\n"
	"\n"
	"		// redraw the avatar with its new appearance\n"
	"		drawRoom(room[state.room], { redrawAvatar: true });\n"
	"	}\n"
	"\n"
	"	onReturn(state.ava);\n"
	"}\n"
	"\n"
	"/* BUILT-IN OPERATORS */\n"
	"function setExp(environment,left,right,onReturn) {\n"
	"	// bitsy.log(\"SET \" + left.name);\n"
	"\n"
	"	if(left.type != \"variable\") {\n"
	"		// not a variable! return null and hope for the best D:\n"
	"		onReturn( null );\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	right.Eval(environment,function(rVal) {\n"
	"		environment.SetVariable( left.name, rVal );\n"
	"		// bitsy.log(\"VAL \" + environment.GetVariable( left.name ) );\n"
	"		left.Eval(environment,function(lVal) {\n"
	"			onReturn( lVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function equalExp(environment,left,right,onReturn) {\n"
	"	// bitsy.log(\"EVAL EQUAL\");\n"
	"	// bitsy.log(left);\n"
	"	// bitsy.log(right);\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal === rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function greaterExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal > rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function lessExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal < rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function greaterEqExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal >= rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function lessEqExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal <= rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function multExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal * rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function divExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal / rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function addExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal + rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"function subExp(environment,left,right,onReturn) {\n"
	"	right.Eval(environment,function(rVal){\n"
	"		left.Eval(environment,function(lVal){\n"
	"			onReturn( lVal - rVal );\n"
	"		});\n"
	"	});\n"
	"}\n"
	"\n"
	"/* ENVIRONMENT */\n"
	"var Environment = function() {\n"
	"	var dialogBuffer = null;\n"
	"	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };\n"
	"	this.GetDialogBuffer = function() { return dialogBuffer; };\n"
	"\n"
	"	var functionMap = {};\n"
	"\n"
	"	// dialog\n"
	"	functionMap[\"say\"] = sayFunc;\n"
	"	functionMap[\"br\"] = linebreakFunc;\n"
	"	functionMap[\"pg\"] = pagebreakFunc;\n"
	"\n"
	"	// text effects\n"
	"	functionMap[\"wvy\"] = wavyFunc;\n"
	"	functionMap[\"/wvy\"] = wavyPopFunc;\n"
	"	functionMap[\"shk\"] = shakyFunc;\n"
	"	functionMap[\"/shk\"] = shakyPopFunc;\n"
	"	functionMap[\"rbw\"] = rainbowFunc;\n"
	"	functionMap[\"/rbw\"] = rainbowPopFunc;\n"
	"	functionMap[\"clr\"] = colorFunc;\n"
	"	functionMap[\"/clr\"] = colorPopFunc;\n"
	"	// drawing text effects\n"
	"	functionMap[\"drwt\"] = drawTileFunc;\n"
	"	functionMap[\"drws\"] = drawSpriteFunc;\n"
	"	functionMap[\"drwi\"] = drawItemFunc;\n"
	"\n"
	"	// room\n"
	"	functionMap[\"end\"] = endFunc;\n"
	"	functionMap[\"exit\"] = exitFunc;\n"
	"	functionMap[\"pal\"] = paletteFunc;\n"
	"	functionMap[\"ava\"] = avatarFunc;\n"
	"\n"
	"	// inventory & variables\n"
	"	functionMap[\"item\"] = itemFunc;\n"
	"	functionMap[\"property\"] = propertyFunc;\n"
	"\n"
	"	// sound\n"
	"	functionMap[\"tune\"] = tuneFunc;\n"
	"	functionMap[\"blip\"] = blipFunc;\n"
	"\n"
	"	// legacy\n"
	"	functionMap[\"clr1\"] = color1Func;\n"
	"	functionMap[\"clr2\"] = color2Func;\n"
	"	functionMap[\"clr3\"] = color3Func;\n"
	"	functionMap[\"print\"] = sayFunc;\n"
	"	functionMap[\"printTile\"] = drawTileFunc;\n"
	"	functionMap[\"printSprite\"] = drawSpriteFunc;\n"
	"	functionMap[\"printItem\"] = drawItemFunc;\n"
	"\n"
	"	// DEBUG\n"
	"	functionMap[\"_debugOnlyPrintFont\"] = printFontFunc;\n"
	"\n"
	"	// EXPERIMENTAL\n"
	"	// functionMap[\"yak\"] = yakFunc;\n"
	"	// functionMap[\"/yak\"] = yakPopFunc;\n"
	"\n"
	"	this.HasFunction = function(name) { return functionMap[name] != undefined; };\n"
	"	this.EvalFunction = function(name,parameters,onReturn,env) {\n"
	"		if (env == undefined || env == null) {\n"
	"			env = this;\n"
	"		}\n"
	"\n"
	"		functionMap[name](env, parameters, onReturn);\n"
	"	}\n"
	"\n"
	"	var variableMap = {};\n"
	"\n"
	"	this.HasVariable = function(name) { return variableMap[name] != undefined; };\n"
	"	this.GetVariable = function(name) { return variableMap[name]; };\n"
	"	this.SetVariable = function(name,value,useHandler) {\n"
	"		// bitsy.log(\"SET VARIABLE \" + name + \" = \" + value);\n"
	"		if(useHandler === undefined) useHandler = true;\n"
	"		variableMap[name] = value;\n"
	"		if(onVariableChangeHandler != null && useHandler){\n"
	"			onVariableChangeHandler(name);\n"
	"		}\n"
	"	};\n"
	"	this.DeleteVariable = function(name,useHandler) {\n"
	"		if(useHandler === undefined) useHandler = true;\n"
	"		if(variableMap[name] != undefined) {\n"
	"			variableMap.delete(name);\n"
	"			if(onVariableChangeHandler != null && useHandler) {\n"
	"				onVariableChangeHandler(name);\n"
	"			}\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var operatorMap = {};\n"
	"	operatorMap[\"=\"] = setExp;\n"
	"	operatorMap[\"==\"] = equalExp;\n"
	"	operatorMap[\">\"] = greaterExp;\n"
	"	operatorMap[\"<\"] = lessExp;\n"
	"	operatorMap[\">=\"] = greaterEqExp;\n"
	"	operatorMap[\"<=\"] = lessEqExp;\n"
	"	operatorMap[\"*\"] = multExp;\n"
	"	operatorMap[\"/\"] = divExp;\n"
	"	operatorMap[\"+\"] = addExp;\n"
	"	operatorMap[\"-\"] = subExp;\n"
	"\n"
	"	this.HasOperator = function(sym) { return operatorMap[sym] != undefined; };\n"
	"	this.EvalOperator = function(sym,left,right,onReturn) {\n"
	"		operatorMap[ sym ]( this, left, right, onReturn );\n"
	"	}\n"
	"\n"
	"	var scriptMap = {};\n"
	"	this.HasScript = function(name) { return scriptMap[name] != undefined; };\n"
	"	this.GetScript = function(name) { return scriptMap[name]; };\n"
	"	this.SetScript = function(name,script) { scriptMap[name] = script; };\n"
	"\n"
	"	var onVariableChangeHandler = null;\n"
	"	this.SetOnVariableChangeHandler = function(onVariableChange) {\n"
	"		onVariableChangeHandler = onVariableChange;\n"
	"	}\n"
	"	this.GetVariableNames = function() {\n"
	"		var variableNames = [];\n"
	"\n"
	"		for (var key in variableMap) {\n"
	"			variableNames.push(key);\n"
	"		}\n"
	"\n"
	"		return variableNames;\n"
	"	}\n"
	"}\n"
	"\n"
	"// Local environment for a single run of a script: knows local context\n"
	"var LocalEnvironment = function(parentEnvironment) {\n"
	"	// this.SetDialogBuffer // not allowed in local environment?\n"
	"	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };\n"
	"\n"
	"	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };\n"
	"	this.EvalFunction = function(name,parameters,onReturn,env) {\n"
	"		if (env == undefined || env == null) {\n"
	"			env = this;\n"
	"		}\n"
	"\n"
	"		parentEnvironment.EvalFunction(name,parameters,onReturn,env);\n"
	"	}\n"
	"\n"
	"	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };\n"
	"	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };\n"
	"	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };\n"
	"	// this.DeleteVariable // not needed in local environment?\n"
	"\n"
	"	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };\n"
	"	this.EvalOperator = function(sym,left,right,onReturn,env) {\n"
	"		if (env == undefined || env == null) {\n"
	"			env = this;\n"
	"		}\n"
	"\n"
	"		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);\n"
	"	};\n"
	"\n"
	"	// TODO : I don't *think* any of this is required by the local environment\n"
	"	// this.HasScript\n"
	"	// this.GetScript\n"
	"	// this.SetScript\n"
	"\n"
	"	// TODO : pretty sure these debug methods aren't required by the local environment either\n"
	"	// this.SetOnVariableChangeHandler\n"
	"	// this.GetVariableNames\n"
	"\n"
	"	/* Here's where specific local context data goes:\n"
	"	 * this includes access to the object running the script\n"
	"	 * and any properties it may have (so far only \"locked\")\n"
	"	 */\n"
	"\n"
	"	// The local environment knows what object called it -- currently only used to access properties\n"
	"	var curObject = null;\n"
	"	this.HasObject = function() { return curObject != undefined && curObject != null; }\n"
	"	this.SetObject = function(object) { curObject = object; }\n"
	"	this.GetObject = function() { return curObject; }\n"
	"\n"
	"	// accessors for properties of the object that's running the script\n"
	"	this.HasProperty = function(name) {\n"
	"		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {\n"
	"			return true;\n"
	"		}\n"
	"		else {\n"
	"			return false;\n"
	"		}\n"
	"	};\n"
	"	this.GetProperty = function(name) {\n"
	"		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {\n"
	"			return curObject.property[name]; // TODO : should these be getters and setters instead?\n"
	"		}\n"
	"		else {\n"
	"			return null;\n"
	"		}\n"
	"	};\n"
	"	this.SetProperty = function(name, value) {\n"
	"		// NOTE : for now, we need to gaurd against creating new properties\n"
	"		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {\n"
	"			curObject.property[name] = value;\n"
	"		}\n"
	"	};\n"
	"}\n"
	"\n"
	"function leadingWhitespace(depth) {\n"
	"	var str = \"\";\n"
	"	for(var i = 0; i < depth; i++) {\n"
	"		str += \"  \"; // two spaces per indent\n"
	"	}\n"
	"	// bitsy.log(\"WHITESPACE \" + depth + \" ::\" + str + \"::\");\n"
	"	return str;\n"
	"}\n"
	"\n"
	"/* NODES */\n"
	"var TreeRelationship = function() {\n"
	"	this.parent = null;\n"
	"	this.children = [];\n"
	"\n"
	"	this.AddChild = function(node) {\n"
	"		this.children.push(node);\n"
	"		node.parent = this;\n"
	"	};\n"
	"\n"
	"	this.AddChildren = function(nodeList) {\n"
	"		for (var i = 0; i < nodeList.length; i++) {\n"
	"			this.AddChild(nodeList[i]);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.SetChildren = function(nodeList) {\n"
	"		this.children = [];\n"
	"		this.AddChildren(nodeList);\n"
	"	};\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit(this, depth);\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			this.children[i].VisitAll( visitor, depth + 1 );\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.rootId = null; // for debugging\n"
	"	this.GetId = function() {\n"
	"		// bitsy.log(this);\n"
	"		if (this.rootId != null) {\n"
	"			return this.rootId;\n"
	"		}\n"
	"		else if (this.parent != null) {\n"
	"			var parentId = this.parent.GetId();\n"
	"			if (parentId != null) {\n"
	"				return parentId + \"_\" + this.parent.children.indexOf(this);\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			return null;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function DialogBlockNode(doIndentFirstLine) {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = \"dialog_block\";\n"
	"\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsy.log(\"EVAL BLOCK \" + this.children.length);\n"
	"\n"
	"		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"			events.Raise(\"script_node_enter\", { id: this.GetId() });\n"
	"		}\n"
	"\n"
	"		var lastVal = null;\n"
	"		var i = 0;\n"
	"\n"
	"		function evalChildren(children, done) {\n"
	"			if (i < children.length) {\n"
	"				// bitsy.log(\">> CHILD \" + i);\n"
	"				children[i].Eval(environment, function(val) {\n"
	"					// bitsy.log(\"<< CHILD \" + i);\n"
	"					lastVal = val;\n"
	"					i++;\n"
	"					evalChildren(children,done);\n"
	"				});\n"
	"			}\n"
	"			else {\n"
	"				done();\n"
	"			}\n"
	"		};\n"
	"\n"
	"		var self = this;\n"
	"		evalChildren(this.children, function() {\n"
	"			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"				events.Raise(\"script_node_exit\", { id: self.GetId() });\n"
	"			}\n"
	"\n"
	"			onReturn(lastVal);\n"
	"		});\n"
	"	}\n"
	"\n"
	"	if (doIndentFirstLine === undefined) {\n"
	"		doIndentFirstLine = true; // This is just for serialization\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		if (depth === undefined) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		var str = \"\";\n"
	"		var lastNode = null;\n"
	"\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"\n"
	"			var curNode = this.children[i];\n"
	"\n"
	"			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);\n"
	"			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === \"function\" && lastNode.name === \"br\");\n"
	"\n"
	"			if (shouldIndentFirstLine || shouldIndentAfterLinebreak) {\n"
	"				str += leadingWhitespace(depth);\n"
	"			}\n"
	"\n"
	"			str += curNode.Serialize(depth);\n"
	"\n"
	"			lastNode = curNode;\n"
	"		}\n"
	"\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function CodeBlockNode() {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = \"code_block\";\n"
	"\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsy.log(\"EVAL BLOCK \" + this.children.length);\n"
	"\n"
	"		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"			events.Raise(\"script_node_enter\", { id: this.GetId() });\n"
	"		}\n"
	"\n"
	"		var lastVal = null;\n"
	"		var i = 0;\n"
	"\n"
	"		function evalChildren(children, done) {\n"
	"			if (i < children.length) {\n"
	"				// bitsy.log(\">> CHILD \" + i);\n"
	"				children[i].Eval(environment, function(val) {\n"
	"					// bitsy.log(\"<< CHILD \" + i);\n"
	"					lastVal = val;\n"
	"					i++;\n"
	"					evalChildren(children,done);\n"
	"				});\n"
	"			}\n"
	"			else {\n"
	"				done();\n"
	"			}\n"
	"		};\n"
	"\n"
	"		var self = this;\n"
	"		evalChildren(this.children, function() {\n"
	"			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"				events.Raise(\"script_node_exit\", { id: self.GetId() });\n"
	"			}\n"
	"\n"
	"			onReturn(lastVal);\n"
	"		});\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		if(depth === undefined) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		// bitsy.log(\"SERIALIZE BLOCK!!!\");\n"
	"		// bitsy.log(depth);\n"
	"		// bitsy.log(doIndentFirstLine);\n"
	"\n"
	"		var str = \"{\"; // todo: increase scope of Sym?\n"
	"\n"
	"		// TODO : do code blocks ever have more than one child anymore????\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			var curNode = this.children[i];\n"
	"			str += curNode.Serialize(depth);\n"
	"		}\n"
	"\n"
	"		str += \"}\";\n"
	"\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function isInlineCode(node) {\n"
	"	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);\n"
	"}\n"
	"\n"
	"function isUndefinedBlock(node) {\n"
	"	return node.type === \"code_block\" && node.children.length > 0 && node.children[0].type === \"undefined\";\n"
	"}\n"
	"\n"
	"var textEffectBlockNames = [\"clr1\", \"clr2\", \"clr3\", \"wvy\", \"shk\", \"rbw\", \"printSprite\", \"printItem\", \"printTile\", \"print\", \"say\", \"br\"];\n"
	"function isTextEffectBlock(node) {\n"
	"	if (node.type === \"code_block\") {\n"
	"		if (node.children.length > 0 && node.children[0].type === \"function\") {\n"
	"			var func = node.children[0];\n"
	"			return textEffectBlockNames.indexOf(func.name) != -1;\n"
	"		}\n"
	"	}\n"
	"	return false;\n"
	"}\n"
	"\n"
	"var listBlockTypes = [\"sequence\", \"cycle\", \"shuffle\", \"if\"];\n"
	"function isMultilineListBlock(node) {\n"
	"	if (node.type === \"code_block\") {\n"
	"		if (node.children.length > 0) {\n"
	"			var child = node.children[0];\n"
	"			return listBlockTypes.indexOf(child.type) != -1;\n"
	"		}\n"
	"	}\n"
	"	return false;\n"
	"}\n"
	"\n"
	"// for round-tripping undefined code through the parser (useful for hacks!)\n"
	"function UndefinedNode(sourceStr) {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = \"undefined\";\n"
	"	this.source = sourceStr;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		toggleTextEffect(environment, \"_debug_highlight\");\n"
	"		sayFunc(environment, [\"{\" + sourceStr + \"}\"], function() {\n"
	"			onReturn(null);\n"
	"		});\n"
	"		toggleTextEffect(environment, \"_debug_highlight\");\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		return this.source;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return \"undefined\" + \" \" + this.GetId();\n"
	"	}\n"
	"}\n"
	"\n"
	"function FuncNode(name, args) {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = \"function\";\n"
	"	this.name = name;\n"
	"	this.args = args;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"			events.Raise(\"script_node_enter\", { id: this.GetId() });\n"
	"		}\n"
	"\n"
	"		var self = this; // hack to deal with scope (TODO : move up higher?)\n"
	"\n"
	"		var argumentValues = [];\n"
	"		var i = 0;\n"
	"\n"
	"		function evalArgs(args, done) {\n"
	"			// TODO : really hacky way to make we get the first\n"
	"			// symbol's NAME instead of its variable value\n"
	"			// if we are trying to do something with a property\n"
	"			if (self.name === \"property\" && i === 0 && i < args.length) {\n"
	"				if (args[i].type === \"variable\") {\n"
	"					argumentValues.push(args[i].name);\n"
	"					i++;\n"
	"				}\n"
	"				else {\n"
	"					// first argument for a property MUST be a variable symbol\n"
	"					// -- so skip everything if it's not!\n"
	"					i = args.length;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (i < args.length) {\n"
	"				// Evaluate each argument\n"
	"				args[i].Eval(\n"
	"					environment,\n"
	"					function(val) {\n"
	"						argumentValues.push(val);\n"
	"						i++;\n"
	"						evalArgs(args, done);\n"
	"					});\n"
	"			}\n"
	"			else {\n"
	"				done();\n"
	"			}\n"
	"		};\n"
	"\n"
	"		evalArgs(\n"
	"			this.args,\n"
	"			function() {\n"
	"				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {\n"
	"					events.Raise(\"script_node_exit\", { id: self.GetId() });\n"
	"				}\n"
	"\n"
	"				environment.EvalFunction(self.name, argumentValues, onReturn);\n"
	"			});\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var isDialogBlock = this.parent.type === \"dialog_block\";\n"
	"		if (isDialogBlock && this.name === \"say\") {\n"
	"			// TODO this could cause problems with \"real\" print functions\n"
	"			return this.args[0].value; // first argument should be the text of the {print} func\n"
	"		}\n"
	"		else if (isDialogBlock && this.name === \"br\") {\n"
	"			return \"\\n\";\n"
	"		}\n"
	"		else {\n"
	"			var str = \"\";\n"
	"			str += this.name;\n"
	"			for(var i = 0; i < this.args.length; i++) {\n"
	"				str += \" \";\n"
	"				str += this.args[i].Serialize(depth);\n"
	"			}\n"
	"			return str;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.name + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function LiteralNode(value) {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = \"literal\";\n"
	"	this.value = value;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		onReturn(this.value);\n"
	"	};\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\";\n"
	"\n"
	"		if (this.value === null) {\n"
	"			return str;\n"
	"		}\n"
	"\n"
	"		if (typeof this.value === \"string\") {\n"
	"			str += '\"';\n"
	"		}\n"
	"\n"
	"		str += this.value;\n"
	"\n"
	"		if (typeof this.value === \"string\") {\n"
	"			str += '\"';\n"
	"		}\n"
	"\n"
	"		return str;\n"
	"	};\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.value + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function VarNode(name) {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = \"variable\";\n"
	"	this.name = name;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		// bitsy.log(\"EVAL \" + this.name + \" \" + environment.HasVariable(this.name) + \" \" + environment.GetVariable(this.name));\n"
	"		if( environment.HasVariable(this.name) )\n"
	"			onReturn( environment.GetVariable( this.name ) );\n"
	"		else\n"
	"			onReturn(null); // not a valid variable -- return null and hope that's ok\n"
	"	} // TODO: might want to store nodes in the variableMap instead of values???\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\" + this.name;\n"
	"		return str;\n"
	"	}\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.name + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function ExpNode(operator, left, right) {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = \"operator\";\n"
	"	this.operator = operator;\n"
	"	this.left = left;\n"
	"	this.right = right;\n"
	"\n"
	"	this.Eval = function(environment,onReturn) {\n"
	"		// bitsy.log(\"EVAL \" + this.operator);\n"
	"		var self = this; // hack to deal with scope\n"
	"		environment.EvalOperator( this.operator, this.left, this.right, \n"
	"			function(val){\n"
	"				// bitsy.log(\"EVAL EXP \" + self.operator + \" \" + val);\n"
	"				onReturn(val);\n"
	"			} );\n"
	"		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods\n"
	"	};\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var isNegativeNumber = this.operator === \"-\" && this.left.type === \"literal\" && this.left.value === null;\n"
	"\n"
	"		if (!isNegativeNumber) {\n"
	"			var str = \"\";\n"
	"\n"
	"			if (this.left != undefined && this.left != null) {\n"
	"				str += this.left.Serialize(depth) + \" \";\n"
	"			}\n"
	"\n"
	"			str += this.operator;\n"
	"\n"
	"			if (this.right != undefined && this.right != null) {\n"
	"				str += \" \" + this.right.Serialize(depth);\n"
	"			}\n"
	"\n"
	"			return str;\n"
	"		}\n"
	"		else {\n"
	"			return this.operator + this.right.Serialize(depth); // hacky but seems to work\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit( this, depth );\n"
	"		if(this.left != null)\n"
	"			this.left.VisitAll( visitor, depth + 1 );\n"
	"		if(this.right != null)\n"
	"			this.right.VisitAll( visitor, depth + 1 );\n"
	"	};\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.operator + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function SequenceBase() {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\";\n"
	"		str += this.type + \"\\n\";\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			str += leadingWhitespace(depth + 1) + Sym.List + \" \";\n"
	"			str += this.children[i].Serialize(depth + 2);\n"
	"			str += \"\\n\";\n"
	"		}\n"
	"		str += leadingWhitespace(depth);\n"
	"		return str;\n"
	"	};\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit(this, depth);\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			this.children[i].VisitAll( visitor, depth + 1 );\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function SequenceNode(options) {\n"
	"	SequenceBase.call(this);\n"
	"\n"
	"	this.type = \"sequence\";\n"
	"	this.AddChildren(options);\n"
	"\n"
	"	var index = 0;\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsy.log(\"SEQUENCE \" + index);\n"
	"		this.children[index].Eval(environment, onReturn);\n"
	"\n"
	"		var next = index + 1;\n"
	"		if (next < this.children.length) {\n"
	"			index = next;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function CycleNode(options) {\n"
	"	SequenceBase.call(this);\n"
	"\n"
	"	this.type = \"cycle\";\n"
	"	this.AddChildren(options);\n"
	"\n"
	"	var index = 0;\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsy.log(\"CYCLE \" + index);\n"
	"		this.children[index].Eval(environment, onReturn);\n"
	"\n"
	"		var next = index + 1;\n"
	"		if (next < this.children.length) {\n"
	"			index = next;\n"
	"		}\n"
	"		else {\n"
	"			index = 0;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function ShuffleNode(options) {\n"
	"	SequenceBase.call(this);\n"
	"\n"
	"	this.type = \"shuffle\";\n"
	"	this.AddChildren(options);\n"
	"\n"
	"	var optionsShuffled = [];\n"
	"	function shuffle(options) {\n"
	"		optionsShuffled = [];\n"
	"		var optionsUnshuffled = options.slice();\n"
	"		while (optionsUnshuffled.length > 0) {\n"
	"			var i = Math.floor(Math.random() * optionsUnshuffled.length);\n"
	"			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);\n"
	"		}\n"
	"	}\n"
	"	shuffle(this.children);\n"
	"\n"
	"	var index = 0;\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		optionsShuffled[index].Eval(environment, onReturn);\n"
	"		\n"
	"		index++;\n"
	"		if (index >= this.children.length) {\n"
	"			shuffle(this.children);\n"
	"			index = 0;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"// TODO : rename? ConditionalNode?\n"
	"function IfNode(conditions, results, isSingleLine) {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = \"if\";\n"
	"\n"
	"	for (var i = 0; i < conditions.length; i++) {\n"
	"		this.AddChild(new ConditionPairNode(conditions[i], results[i]));\n"
	"	}\n"
	"\n"
	"	var self = this;\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		// bitsy.log(\"EVAL IF\");\n"
	"		var i = 0;\n"
	"		function TestCondition() {\n"
	"			self.children[i].Eval(environment, function(result) {\n"
	"				if (result.conditionValue == true) {\n"
	"					onReturn(result.resultValue);\n"
	"				}\n"
	"				else if (i+1 < self.children.length) {\n"
	"					i++;\n"
	"					TestCondition();\n"
	"				}\n"
	"				else {\n"
	"					onReturn(null);\n"
	"				}\n"
	"			});\n"
	"		};\n"
	"		TestCondition();\n"
	"	};\n"
	"\n"
	"	if (isSingleLine === undefined) {\n"
	"		isSingleLine = false; // This is just for serialization\n"
	"	}\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\";\n"
	"		if(isSingleLine) {\n"
	"			// HACKY - should I even keep this mode???\n"
	"			str += this.children[0].children[0].Serialize() + \" ? \" + this.children[0].children[1].Serialize();\n"
	"			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {\n"
	"				str += \" \" + Sym.ElseExp + \" \" + this.children[1].children[1].Serialize();\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			str += \"\\n\";\n"
	"			for (var i = 0; i < this.children.length; i++) {\n"
	"				str += this.children[i].Serialize(depth);\n"
	"			}\n"
	"			str += leadingWhitespace(depth);\n"
	"		}\n"
	"		return str;\n"
	"	};\n"
	"\n"
	"	this.IsSingleLine = function() {\n"
	"		return isSingleLine;\n"
	"	};\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit(this, depth);\n"
	"\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			this.children[i].VisitAll(visitor, depth + 1);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.mode + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function ConditionPairNode(condition, result) {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = \"condition_pair\";\n"
	"\n"
	"	this.AddChild(condition);\n"
	"	this.AddChild(result);\n"
	"\n"
	"	var self = this;\n"
	"\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		self.children[0].Eval(environment, function(conditionSuccess) {\n"
	"			if (conditionSuccess) {\n"
	"				self.children[1].Eval(environment, function(resultValue) {\n"
	"					onReturn({ conditionValue:true, resultValue:resultValue });\n"
	"				});\n"
	"			}\n"
	"			else {\n"
	"				onReturn({ conditionValue:false });\n"
	"			}\n"
	"		});\n"
	"	};\n"
	"\n"
	"	this.Serialize = function(depth) {\n"
	"		var str = \"\";\n"
	"		str += leadingWhitespace(depth + 1);\n"
	"		str += Sym.List + \" \" + this.children[0].Serialize(depth) + \" \" + Sym.ConditionEnd + Sym.Linebreak;\n"
	"		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;\n"
	"		return str;\n"
	"	};\n"
	"\n"
	"	this.VisitAll = function(visitor, depth) {\n"
	"		if (depth == undefined || depth == null) {\n"
	"			depth = 0;\n"
	"		}\n"
	"\n"
	"		visitor.Visit(this, depth);\n"
	"\n"
	"		for (var i = 0; i < this.children.length; i++) {\n"
	"			this.children[i].VisitAll(visitor, depth + 1);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"function ElseNode() {\n"
	"	TreeRelationship.call(this);\n"
	"\n"
	"	this.type = Sym.Else;\n"
	"\n"
	"	this.Eval = function(environment, onReturn) {\n"
	"		onReturn(true);\n"
	"	};\n"
	"\n"
	"	this.Serialize = function() {\n"
	"		return Sym.Else;\n"
	"	};\n"
	"\n"
	"	this.ToString = function() {\n"
	"		return this.type + \" \" + this.mode + \" \" + this.GetId();\n"
	"	};\n"
	"}\n"
	"\n"
	"var Sym = {\n"
	"	DialogOpen : '\"\"\"',\n"
	"	DialogClose : '\"\"\"',\n"
	"	CodeOpen : \"{\",\n"
	"	CodeClose : \"}\",\n"
	"	Linebreak : \"\\n\", // just call it \"break\" ?\n"
	"	Separator : \":\",\n"
	"	List : \"-\",\n"
	"	String : '\"',\n"
	"	ConditionEnd : \"?\",\n"
	"	Else : \"else\",\n"
	"	ElseExp : \":\", // special shorthand for expressions (deprecate?)\n"
	"	Set : \"=\",\n"
	"	Operators : [\"==\", \">=\", \"<=\", \">\", \"<\", \"-\", \"+\", \"/\", \"*\"], // operators need to be in reverse order of precedence\n"
	"};\n"
	"\n"
	"var Parser = function(env) {\n"
	"	var environment = env;\n"
	"\n"
	"	this.Parse = function(scriptStr, rootId) {\n"
	"		var rootNode = new DialogBlockNode();\n"
	"		rootNode.rootId = rootId;\n"
	"		var state = new ParserState(rootNode, scriptStr);\n"
	"\n"
	"		if (state.MatchAhead(Sym.DialogOpen)) {\n"
	"			// multi-line dialog block\n"
	"			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);\n"
	"			rootNode = new DialogBlockNode();\n"
	"			rootNode.rootId = rootId; // hacky!!\n"
	"			state = new ParserState(rootNode, dialogStr);\n"
	"			state = ParseDialog(state);\n"
	"		}\n"
	"		else {\n"
	"			// single-line dialog block\n"
	"			state = ParseDialog(state);\n"
	"		}\n"
	"\n"
	"		return state.rootNode;\n"
	"	};\n"
	"\n"
	"	var ParserState = function( rootNode, str ) {\n"
	"		this.rootNode = rootNode;\n"
	"		this.curNode = this.rootNode;\n"
	"\n"
	"		var sourceStr = str;\n"
	"		var i = 0;\n"
	"		this.Index = function() { return i; };\n"
	"		this.Count = function() { return sourceStr.length; };\n"
	"		this.Done = function() { return i >= sourceStr.length; };\n"
	"		this.Char = function() { return sourceStr[i]; };\n"
	"		this.Step = function(n) { if(n===undefined) n=1; i += n; };\n"
	"		this.MatchAhead = function(str) {\n"
	"			// bitsy.log(str);\n"
	"			str = \"\" + str; // hack to turn single chars into strings\n"
	"			// bitsy.log(str);\n"
	"			// bitsy.log(str.length);\n"
	"			for (var j = 0; j < str.length; j++) {\n"
	"				if (i + j >= sourceStr.length) {\n"
	"					return false;\n"
	"				}\n"
	"				else if (str[j] != sourceStr[i+j]) {\n"
	"					return false;\n"
	"				}\n"
	"			}\n"
	"			return true;\n"
	"		}\n"
	"		this.Peak = function(end) {\n"
	"			var str = \"\";\n"
	"			var j = i;\n"
	"			// bitsy.log(j);\n"
	"			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {\n"
	"				str += sourceStr[j];\n"
	"				j++;\n"
	"			}\n"
	"			// bitsy.log(\"PEAK ::\" + str + \"::\");\n"
	"			return str;\n"
	"		}\n"
	"		this.ConsumeBlock = function(open, close, includeSymbols) {\n"
	"			if (includeSymbols === undefined || includeSymbols === null) {\n"
	"				includeSymbols = false;\n"
	"			}\n"
	"\n"
	"			var startIndex = i;\n"
	"\n"
	"			var matchCount = 0;\n"
	"			if (this.MatchAhead(open)) {\n"
	"				matchCount++;\n"
	"				this.Step(open.length);\n"
	"			}\n"
	"\n"
	"			while (matchCount > 0 && !this.Done()) {\n"
	"				if (this.MatchAhead(close)) {\n"
	"					matchCount--;\n"
	"					this.Step( close.length );\n"
	"				}\n"
	"				else if (this.MatchAhead(open)) {\n"
	"					matchCount++;\n"
	"					this.Step(open.length);\n"
	"				}\n"
	"				else {\n"
	"					this.Step();\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (includeSymbols) {\n"
	"				return sourceStr.slice(startIndex, i);\n"
	"			}\n"
	"			else {\n"
	"				return sourceStr.slice(startIndex + open.length, i - close.length);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		this.Print = function() { bitsy.log(sourceStr); };\n"
	"		this.Source = function() { return sourceStr; };\n"
	"	};\n"
	"\n"
	"	/*\n"
	"		ParseDialog():\n"
	"		This function adds {print} nodes and linebreak {br} nodes to display text,\n"
	"		interleaved with bracketed code nodes for functions and flow control,\n"
	"		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.\n"
	"		The parsing of those code blocks is handled by ParseCode.\n"
	"\n"
	"		Note on parsing newline characters:\n"
	"		- there should be an implicit linebreak {br} after each dialog line\n"
	"		- a \"dialog line\" is defined as any line that either:\n"
	"			- 1) contains dialog text (any text outside of a code block)\n"
	"			- 2) is entirely empty (no text, no code)\n"
	"			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)\n"
	"		- lines *only* containing {code} blocks are not dialog lines\n"
	"\n"
	"		NOTE TO SELF: all the state I'm storing in here feels like\n"
	"		evidence that the parsing system kind of broke down at this point :(\n"
	"		Maybe it would feel better if I move into the \"state\" object\n"
	"	*/\n"
	"	function ParseDialog(state) {\n"
	"		var curLineNodeList = [];\n"
	"		var curText = \"\";\n"
	"		var curLineIsEmpty = true;\n"
	"		var curLineContainsDialogText = false;\n"
	"		var prevLineIsDialogLine = false;\n"
	"\n"
	"		var curLineIsDialogLine = function() {\n"
	"			return curLineContainsDialogText || curLineIsEmpty;\n"
	"		}\n"
	"\n"
	"		var resetLineStateForNewLine = function() {\n"
	"			prevLineIsDialogLine = curLineIsDialogLine();\n"
	"			curLineContainsDialogText = false;\n"
	"			curLineIsEmpty = true;\n"
	"			curText = \"\";\n"
	"			curLineNodeList = [];\n"
	"		}\n"
	"\n"
	"		var tryAddTextNodeToList = function() {\n"
	"			if (curText.length > 0) {\n"
	"				var sayNode = new FuncNode(\"say\", [new LiteralNode(curText)]);\n"
	"				curLineNodeList.push(sayNode);\n"
	"\n"
	"				curText = \"\";\n"
	"				curLineIsEmpty = false;\n"
	"				curLineContainsDialogText = true;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var addCodeNodeToList = function() {\n"
	"			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);\n"
	"			var codeState = new ParserState(new CodeBlockNode(), codeSource);\n"
	"			codeState = ParseCode(codeState);\n"
	"			var codeBlockNode = codeState.rootNode;\n"
	"			curLineNodeList.push(codeBlockNode);\n"
	"\n"
	"			curLineIsEmpty = false;\n"
	"\n"
	"			// lists count as dialog text, because they can contain it\n"
	"			if (isMultilineListBlock(codeBlockNode)) {\n"
	"				curLineContainsDialogText = true;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var tryAddLinebreakNodeToList = function() {\n"
	"			if (prevLineIsDialogLine) {\n"
	"				var linebreakNode = new FuncNode(\"br\", []);\n"
	"				curLineNodeList.unshift(linebreakNode);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var addLineNodesToParent = function() {\n"
	"			for (var i = 0; i < curLineNodeList.length; i++) {\n"
	"				state.curNode.AddChild(curLineNodeList[i]);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		while (!state.Done()) {\n"
	"			if (state.MatchAhead(Sym.CodeOpen)) { // process code block\n"
	"				// add any buffered text to a print node, and parse the code\n"
	"				tryAddTextNodeToList();\n"
	"				addCodeNodeToList();\n"
	"			}\n"
	"			else if (state.MatchAhead(Sym.Linebreak)) { // process new line\n"
	"				// add any buffered text to a print node, \n"
	"				// and add a linebreak if we are between two dialog lines\n"
	"				tryAddTextNodeToList();\n"
	"				tryAddLinebreakNodeToList();\n"
	"\n"
	"				// since we've reached the end of a line\n"
	"				// add stored nodes for this line to the parent node we are building,\n"
	"				// and reset state for the next line\n"
	"				addLineNodesToParent();\n"
	"				resetLineStateForNewLine();\n"
	"\n"
	"				state.Step();\n"
	"			}\n"
	"			else {\n"
	"				// continue adding text to the current text buffer\n"
	"				curText += state.Char();\n"
	"				state.Step();\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// to make sure we don't leave anything behind:\n"
	"		// add buffered text to a print node and add all nodes\n"
	"		// to the current parent node\n"
	"		tryAddTextNodeToList();\n"
	"		tryAddLinebreakNodeToList();\n"
	"		addLineNodesToParent();\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function ParseDialogBlock(state) {\n"
	"		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );\n"
	"\n"
	"		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);\n"
	"		dialogState = ParseDialog( dialogState );\n"
	"\n"
	"		state.curNode.AddChild( dialogState.rootNode );\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	/*\n"
	"		ParseConditional():\n"
	"		A conditional contains a list of conditions that can be\n"
	"		evaluated to true or false, followed by more dialog\n"
	"		that will be evaluated if the condition is true. The first\n"
	"		true condition is the one that gets evaluated.\n"
	"	*/\n"
	"	function ParseConditional(state) {\n"
	"		var conditionStrings = [];\n"
	"		var resultStrings = [];\n"
	"		var curIndex = -1;\n"
	"		var requiredLeadingWhitespace = -1;\n"
	"\n"
	"		// TODO : very similar to sequence parsing - can we share anything?\n"
	"		function parseConditionalItemLine(state) {\n"
	"			var lineText = \"\";\n"
	"			var whitespaceCount = 0;\n"
	"			var isNewCondition = false;\n"
	"			var encounteredNonWhitespace = false;\n"
	"			var encounteredConditionEnd = false;\n"
	"\n"
	"			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {\n"
	"				// count whitespace until we hit the first non-whitespace character\n"
	"				if (!encounteredNonWhitespace) {\n"
	"					if (state.Char() === \" \" || state.Char() === \"\\t\") {\n"
	"						whitespaceCount++;\n"
	"					}\n"
	"					else {\n"
	"						encounteredNonWhitespace = true;\n"
	"\n"
	"						if (state.Char() === Sym.List) {\n"
	"							isNewCondition = true;\n"
	"							whitespaceCount += 2; // count the list seperator AND the following extra space\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"\n"
	"				// if this is the condition, we need to track whether we've\n"
	"				// reached the end of the condition\n"
	"				if (isNewCondition && !encounteredConditionEnd) {\n"
	"					if (state.Char() === Sym.ConditionEnd) {\n"
	"						encounteredConditionEnd = true;\n"
	"					}\n"
	"				}\n"
	"\n"
	"				// add characters one at a time, unless it's a code block\n"
	"				// since code blocks can contain additional sequences inside\n"
	"				// them that will mess up our list item detection\n"
	"				if (state.Char() === Sym.CodeOpen) {\n"
	"					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);\n"
	"				}\n"
	"				else {\n"
	"					if (!encounteredConditionEnd) { // skip all characters including & after the condition end\n"
	"						lineText += state.Char();\n"
	"					}\n"
	"					state.Step();\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (state.Char() === Sym.Linebreak) {\n"
	"				state.Step();\n"
	"			}\n"
	"\n"
	"			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };\n"
	"		}\n"
	"\n"
	"		// TODO : this is copied from sequence parsing; share?\n"
	"		function trimLeadingWhitespace(text, trimLength) {\n"
	"			var textSplit = text.split(Sym.linebreak);\n"
	"			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });\n"
	"			return textSplit.join(Sym.linebreak);\n"
	"		}\n"
	"\n"
	"		while (!state.Done()) {\n"
	"			var lineResults = parseConditionalItemLine(state);\n"
	"\n"
	"			if (lineResults.isNewCondition) {\n"
	"				requiredLeadingWhitespace = lineResults.whitespace;\n"
	"				curIndex++;\n"
	"				conditionStrings[curIndex] = \"\";\n"
	"				resultStrings[curIndex] = \"\";\n"
	"			}\n"
	"\n"
	"			// to avoid extra newlines in nested conditionals, only count lines\n"
	"			// that at least match the whitespace count of the initial line\n"
	"			// NOTE: see the comment in sequence parsing for more details\n"
	"			if (lineResults.whitespace >= requiredLeadingWhitespace) {\n"
	"				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);\n"
	"\n"
	"				if (lineResults.isNewCondition) {\n"
	"					conditionStrings[curIndex] += trimmedText;\n"
	"				}\n"
	"				else {\n"
	"					resultStrings[curIndex] += trimmedText + Sym.Linebreak;\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// hack: cut off the trailing newlines from all the result strings\n"
	"		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });\n"
	"\n"
	"		var conditions = [];\n"
	"		for (var i = 0; i < conditionStrings.length; i++) {\n"
	"			var str = conditionStrings[i].trim();\n"
	"			if (str === Sym.Else) {\n"
	"				conditions.push(new ElseNode());\n"
	"			}\n"
	"			else {\n"
	"				var exp = CreateExpression(str);\n"
	"				conditions.push(exp);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var results = [];\n"
	"		for (var i = 0; i < resultStrings.length; i++) {\n"
	"			var str = resultStrings[i];\n"
	"			var dialogBlockState = new ParserState(new DialogBlockNode(), str);\n"
	"			dialogBlockState = ParseDialog(dialogBlockState);\n"
	"			var dialogBlock = dialogBlockState.rootNode;\n"
	"			results.push(dialogBlock);\n"
	"		}\n"
	"\n"
	"		state.curNode.AddChild(new IfNode(conditions, results));\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function IsSequence(str) {\n"
	"		// bitsy.log(\"IsSequence? \" + str);\n"
	"		return str === \"sequence\" || str === \"cycle\" || str === \"shuffle\";\n"
	"	}\n"
	"\n"
	"	/*\n"
	"		ParseSequence():\n"
	"		Sequence nodes contain a list of dialog block nodes. The order those\n"
	"		nodes are evaluated is determined by the type of sequence:\n"
	"		- sequence: each child node evaluated once in order\n"
	"		- cycle: repeats from the beginning after all nodes evaluate\n"
	"		- shuffle: evaluate in a random order\n"
	"\n"
	"		Each item in a sequence is sepearated by a \"-\" character.\n"
	"		The seperator must come at the beginning of the line,\n"
	"		but may be preceded by whitespace (in any amount).\n"
	"\n"
	"		About whitespace: Whitespace at the start of a line\n"
	"		is ignored if it less than or equal to the count of\n"
	"		whitespace that preceded the list separator (\"-\") at\n"
	"		the start of that item. (The count also includes the\n"
	"		seperator and the extra space after the seperator.)\n"
	"	 */\n"
	"	function ParseSequence(state, sequenceType) {\n"
	"		var itemStrings = [];\n"
	"		var curItemIndex = -1; // -1 indicates not reading an item yet\n"
	"		var requiredLeadingWhitespace = -1;\n"
	"\n"
	"		function parseSequenceItemLine(state) {\n"
	"			var lineText = \"\";\n"
	"			var whitespaceCount = 0;\n"
	"			var isNewListItem = false;\n"
	"			var encounteredNonWhitespace = false;\n"
	"\n"
	"			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {\n"
	"				// count whitespace until we hit the first non-whitespace character\n"
	"				if (!encounteredNonWhitespace) {\n"
	"					if (state.Char() === \" \" || state.Char() === \"\\t\") {\n"
	"						whitespaceCount++;\n"
	"					}\n"
	"					else {\n"
	"						encounteredNonWhitespace = true;\n"
	"\n"
	"						if (state.Char() === Sym.List) {\n"
	"							isNewListItem = true;\n"
	"							whitespaceCount += 2; // count the list seperator AND the following extra space\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"\n"
	"				// add characters one at a time, unless it's a code block\n"
	"				// since code blocks can contain additional sequences inside\n"
	"				// them that will mess up our list item detection\n"
	"				if (state.Char() === Sym.CodeOpen) {\n"
	"					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);\n"
	"				}\n"
	"				else {\n"
	"					lineText += state.Char();\n"
	"					state.Step();\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (state.Char() === Sym.Linebreak) {\n"
	"				state.Step();\n"
	"			}\n"
	"\n"
	"			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };\n"
	"		}\n"
	"\n"
	"		function trimLeadingWhitespace(text, trimLength) {\n"
	"			// the split and join is necessary because a single \"line\"\n"
	"			// can contain sequences that may contain newlines of their own\n"
	"			// (we treat them all as one \"line\" for sequence parsing purposes)\n"
	"			var textSplit = text.split(Sym.linebreak);\n"
	"			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });\n"
	"			return textSplit.join(Sym.linebreak);\n"
	"		}\n"
	"\n"
	"		while (!state.Done()) {\n"
	"			var lineResults = parseSequenceItemLine(state);\n"
	"\n"
	"			if (lineResults.isNewListItem) {\n"
	"				requiredLeadingWhitespace = lineResults.whitespace;\n"
	"				curItemIndex++;\n"
	"				itemStrings[curItemIndex] = \"\";\n"
	"			}\n"
	"\n"
	"			// to avoid double counting closing lines (empty ones ending in a curly brace)\n"
	"			// we only allow lines that have at least as much whitespace as the start of the list item\n"
	"			// TODO : I think right now this leads to a bug if the list item's indentation is less than\n"
	"			// its parent code block... hopefully that won't be a big deal for now\n"
	"			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but\n"
	"			// that would require more consideration and testing)\n"
	"			if (lineResults.whitespace >= requiredLeadingWhitespace) {\n"
	"				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);\n"
	"				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// a bit hacky: cut off the trailing newlines from all the items\n"
	"		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });\n"
	"\n"
	"		var options = [];\n"
	"		for (var i = 0; i < itemStrings.length; i++) {\n"
	"			var str = itemStrings[i];\n"
	"			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);\n"
	"			dialogBlockState = ParseDialog(dialogBlockState);\n"
	"			var dialogBlock = dialogBlockState.rootNode;\n"
	"			options.push(dialogBlock);\n"
	"		}\n"
	"\n"
	"		if (sequenceType === \"sequence\") {\n"
	"			state.curNode.AddChild(new SequenceNode(options));\n"
	"		}\n"
	"		else if (sequenceType === \"cycle\") {\n"
	"			state.curNode.AddChild(new CycleNode(options));\n"
	"		}\n"
	"		else if (sequenceType === \"shuffle\") {\n"
	"			state.curNode.AddChild(new ShuffleNode(options));\n"
	"		}\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function ParseFunction(state, funcName) {\n"
	"		bitsy.log(\"~~~ PARSE FUNCTION \" + funcName);\n"
	"\n"
	"		var args = [];\n"
	"\n"
	"		var curSymbol = \"\";\n"
	"		function OnSymbolEnd() {\n"
	"			curSymbol = curSymbol.trim();\n"
	"			// bitsy.log(\"PARAMTER \" + curSymbol);\n"
	"			args.push( StringToValue(curSymbol) );\n"
	"			// bitsy.log(args);\n"
	"			curSymbol = \"\";\n"
	"		}\n"
	"\n"
	"		while( !( state.Char() === \"\\n\" || state.Done() ) ) {\n"
	"			if( state.MatchAhead(Sym.CodeOpen) ) {\n"
	"				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));\n"
	"				codeBlockState = ParseCode( codeBlockState );\n"
	"				var codeBlock = codeBlockState.rootNode;\n"
	"				args.push( codeBlock );\n"
	"				curSymbol = \"\";\n"
	"			}\n"
	"			else if( state.MatchAhead(Sym.String) ) {\n"
	"				/* STRING LITERAL */\n"
	"				var str = state.ConsumeBlock(Sym.String, Sym.String);\n"
	"				// bitsy.log(\"STRING \" + str);\n"
	"				args.push( new LiteralNode(str) );\n"
	"				curSymbol = \"\";\n"
	"			}\n"
	"			else if(state.Char() === \" \" && curSymbol.length > 0) {\n"
	"				OnSymbolEnd();\n"
	"			}\n"
	"			else {\n"
	"				curSymbol += state.Char();\n"
	"			}\n"
	"			state.Step();\n"
	"		}\n"
	"\n"
	"		if(curSymbol.length > 0) {\n"
	"			OnSymbolEnd();\n"
	"		}\n"
	"\n"
	"		state.curNode.AddChild( new FuncNode( funcName, args ) );\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function IsValidVariableName(str) {\n"
	"		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n"
	"		var isValid = reg.test(str);\n"
	"		// bitsy.log(\"VALID variable??? \" + isValid);\n"
	"		return isValid;\n"
	"	}\n"
	"\n"
	"	function StringToValue(valStr) {\n"
	"		if(valStr[0] === Sym.CodeOpen) {\n"
	"			// CODE BLOCK!!!\n"
	"			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky\n"
	"			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);\n"
	"			codeBlockState = ParseCode( codeBlockState );\n"
	"			return codeBlockState.rootNode;\n"
	"		}\n"
	"		else if(valStr[0] === Sym.String) {\n"
	"			// STRING!!\n"
	"			// bitsy.log(\"STRING\");\n"
	"			var str = \"\";\n"
	"			var i = 1;\n"
	"			while (i < valStr.length && valStr[i] != Sym.String) {\n"
	"				str += valStr[i];\n"
	"				i++;\n"
	"			}\n"
	"			// bitsy.log(str);\n"
	"			return new LiteralNode( str );\n"
	"		}\n"
	"		else if(valStr === \"true\") {\n"
	"			// BOOL\n"
	"			return new LiteralNode( true );\n"
	"		}\n"
	"		else if(valStr === \"false\") {\n"
	"			// BOOL\n"
	"			return new LiteralNode( false );\n"
	"		}\n"
	"		else if( !isNaN(parseFloat(valStr)) ) {\n"
	"			// NUMBER!!\n"
	"			// bitsy.log(\"NUMBER!!! \" + valStr);\n"
	"			return new LiteralNode( parseFloat(valStr) );\n"
	"		}\n"
	"		else if(IsValidVariableName(valStr)) {\n"
	"			// VARIABLE!!\n"
	"			// bitsy.log(\"VARIABLE\");\n"
	"			return new VarNode(valStr); // TODO : check for valid potential variables\n"
	"		}\n"
	"		else {\n"
	"			// uh oh\n"
	"			return new LiteralNode(null);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	function CreateExpression(expStr) {\n"
	"		expStr = expStr.trim();\n"
	"\n"
	"		function IsInsideString(index) {\n"
	"			var inString = false;\n"
	"			for(var i = 0; i < expStr.length; i++) {\n"
	"				if(expStr[i] === Sym.String)\n"
	"					inString = !inString;\n"
	"\n"
	"				if(index === i)\n"
	"					return inString;\n"
	"			}\n"
	"			return false;\n"
	"		}\n"
	"\n"
	"		function IsInsideCode(index) {\n"
	"			var count = 0;\n"
	"			for(var i = 0; i < expStr.length; i++) {\n"
	"				if(expStr[i] === Sym.CodeOpen)\n"
	"					count++;\n"
	"				else if(expStr[i] === Sym.CodeClose)\n"
	"					count--;\n"
	"\n"
	"				if(index === i)\n"
	"					return count > 0;\n"
	"			}\n"
	"			return false;\n"
	"		}\n"
	"\n"
	"		var operator = null;\n"
	"\n"
	"		// set is special because other operator can look like it, and it has to go first in the order of operations\n"
	"		var setIndex = expStr.indexOf(Sym.Set);\n"
	"		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator\n"
	"			if( expStr[setIndex+1] != \"=\" && expStr[setIndex-1] != \">\" && expStr[setIndex-1] != \"<\" ) {\n"
	"				// ok it actually IS a set operator and not ==, >=, or <=\n"
	"				operator = Sym.Set;\n"
	"				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing\n"
	"				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);\n"
	"				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );\n"
	"				var exp = new ExpNode( operator, left, right );\n"
	"				return exp;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// special if \"expression\" for single-line if statements\n"
	"		var ifIndex = expStr.indexOf(Sym.ConditionEnd);\n"
	"		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {\n"
	"			operator = Sym.ConditionEnd;\n"
	"			var conditionStr = expStr.substring(0,ifIndex).trim();\n"
	"			var conditions = [ CreateExpression(conditionStr) ];\n"
	"\n"
	"			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);\n"
	"			var results = [];\n"
	"			function AddResult(str) {\n"
	"				var dialogBlockState = new ParserState(new DialogBlockNode(), str);\n"
	"				dialogBlockState = ParseDialog( dialogBlockState );\n"
	"				var dialogBlock = dialogBlockState.rootNode;\n"
	"				results.push( dialogBlock );\n"
	"			}\n"
	"\n"
	"			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?\n"
	"			if(elseIndex > -1) {\n"
	"				conditions.push( new ElseNode() );\n"
	"\n"
	"				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);\n"
	"				var resultStr = resultStr.substring(0,elseIndex);\n"
	"\n"
	"				AddResult( resultStr.trim() );\n"
	"				AddResult( elseStr.trim() );\n"
	"			}\n"
	"			else {\n"
	"				AddResult( resultStr.trim() );\n"
	"			}\n"
	"\n"
	"			return new IfNode( conditions, results, true /*isSingleLine*/ );\n"
	"		}\n"
	"\n"
	"		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {\n"
	"			var opSym = Sym.Operators[i];\n"
	"			var opIndex = expStr.indexOf( opSym );\n"
	"			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {\n"
	"				operator = opSym;\n"
	"				var left = CreateExpression( expStr.substring(0,opIndex) );\n"
	"				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );\n"
	"				var exp = new ExpNode( operator, left, right );\n"
	"				return exp;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		if( operator == null ) {\n"
	"			return StringToValue(expStr);\n"
	"		}\n"
	"	}\n"
	"	this.CreateExpression = CreateExpression;\n"
	"\n"
	"	function IsWhitespace(str) {\n"
	"		return ( str === \" \" || str === \"\\t\" || str === \"\\n\" );\n"
	"	}\n"
	"\n"
	"	function IsExpression(str) {\n"
	"		var tempState = new ParserState(null, str); // hacky\n"
	"		var textOutsideCodeBlocks = \"\";\n"
	"\n"
	"		while (!tempState.Done()) {\n"
	"			if (tempState.MatchAhead(Sym.CodeOpen)) {\n"
	"				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);\n"
	"			}\n"
	"			else {\n"
	"				textOutsideCodeBlocks += tempState.Char();\n"
	"				tempState.Step();\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||\n"
	"				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||\n"
	"				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));\n"
	"\n"
	"		return containsAnyExpressionOperators;\n"
	"	}\n"
	"\n"
	"	function IsLiteral(str) {\n"
	"		var isBool = str === \"true\" || str === \"false\";\n"
	"		var isNum = !isNaN(parseFloat(str));\n"
	"		var isStr = str[0] === '\"' && str[str.length-1] === '\"';\n"
	"		var isVar = IsValidVariableName(str);\n"
	"		var isEmpty = str.length === 0;\n"
	"		return isBool || isNum || isStr || isVar || isEmpty;\n"
	"	}\n"
	"\n"
	"	function ParseExpression(state) {\n"
	"		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing\n"
	"		// bitsy.log(\"EXPRESSION \" + line);\n"
	"		var exp = CreateExpression(line);\n"
	"		// bitsy.log(exp);\n"
	"		state.curNode.AddChild(exp);\n"
	"		state.Step(line.length);\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function IsConditionalBlock(state) {\n"
	"		var peakToFirstListSymbol = state.Peak([Sym.List]);\n"
	"\n"
	"		var foundListSymbol = peakToFirstListSymbol < state.Source().length;\n"
	"\n"
	"		var areAllCharsBeforeListWhitespace = true;\n"
	"		for (var i = 0; i < peakToFirstListSymbol.length; i++) {\n"
	"			if (!IsWhitespace(peakToFirstListSymbol[i])) {\n"
	"				areAllCharsBeforeListWhitespace = false;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);\n"
	"		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);\n"
	"		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;\n"
	"\n"
	"		return foundListSymbol && \n"
	"			areAllCharsBeforeListWhitespace && \n"
	"			hasNoLinebreakBetweenListAndConditionEnd;\n"
	"	}\n"
	"\n"
	"	function ParseCode(state) {\n"
	"		if (IsConditionalBlock(state)) {\n"
	"			state = ParseConditional(state);\n"
	"		}\n"
	"		else if (environment.HasFunction(state.Peak([\" \"]))) { // TODO --- what about newlines???\n"
	"			var funcName = state.Peak([\" \"]);\n"
	"			state.Step(funcName.length);\n"
	"			state = ParseFunction(state, funcName);\n"
	"		}\n"
	"		else if (IsSequence(state.Peak([\" \", Sym.Linebreak]))) {\n"
	"			var sequenceType = state.Peak([\" \", Sym.Linebreak]);\n"
	"			state.Step(sequenceType.length);\n"
	"			state = ParseSequence(state, sequenceType);\n"
	"		}\n"
	"		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {\n"
	"			state = ParseExpression(state);\n"
	"		}\n"
	"		else {\n"
	"			var undefinedSrc = state.Peak([]);\n"
	"			var undefinedNode = new UndefinedNode(undefinedSrc);\n"
	"			state.curNode.AddChild(undefinedNode);\n"
	"		}\n"
	"\n"
	"		// just go to the end now\n"
	"		while (!state.Done()) {\n"
	"			state.Step();\n"
	"		}\n"
	"\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"	function ParseCodeBlock(state) {\n"
	"		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );\n"
	"		var codeState = new ParserState(new CodeBlockNode(), codeStr);\n"
	"		codeState = ParseCode( codeState );\n"
	"		state.curNode.AddChild( codeState.rootNode );\n"
	"		return state;\n"
	"	}\n"
	"\n"
	"}\n"
	"\n"
	"} // Script()\n";

char* world_js =
	"/* BITSY VERSION */\n"
	"// is this the right place for this to live?\n"
	"var version = {\n"
	"	major: 8, // major changes\n"
	"	minor: 12, // smaller changes\n"
	"	devBuildPhase: \"RELEASE\",\n"
	"};\n"
	"function getEngineVersion() {\n"
	"	return version.major + \".\" + version.minor;\n"
	"}\n"
	"\n"
	"/* TEXT CONSTANTS */\n"
	"var titleDialogId = \"title\";\n"
	"\n"
	"// todo : where should this be stored?\n"
	"var tileColorStartIndex = 16;\n"
	"\n"
	"var TextDirection = {\n"
	"	LeftToRight : \"LTR\",\n"
	"	RightToLeft : \"RTL\"\n"
	"};\n"
	"\n"
	"var defaultFontName = \"ascii_small\";\n"
	"\n"
	"/* TUNE CONSTANTS */\n"
	"var barLength = 16; // sixteenth notes\n"
	"var minTuneLength = 1;\n"
	"var maxTuneLength = 16;\n"
	"\n"
	"// chromatic notes\n"
	"var Note = {\n"
	"	NONE 		: -1,\n"
	"	C 			: 0,	// C\n"
	"	C_SHARP 	: 1,	// C sharp / D flat\n"
	"	D 			: 2,	// D\n"
	"	D_SHARP 	: 3,	// D sharp / E flat\n"
	"	E 			: 4,	// E\n"
	"	F 			: 5,	// F\n"
	"	F_SHARP 	: 6,	// F sharp / G flat\n"
	"	G 			: 7,	// G\n"
	"	G_SHARP 	: 8,	// G sharp / A flat\n"
	"	A 			: 9,	// A\n"
	"	A_SHARP 	: 10,	// A sharp / B flat\n"
	"	B 			: 11,	// B\n"
	"	COUNT 		: 12\n"
	"};\n"
	"\n"
	"// solfa notes\n"
	"var Solfa = {\n"
	"	NONE 	: -1,\n"
	"	D 		: 0,	// Do\n"
	"	R 		: 1,	// Re\n"
	"	M 		: 2,	// Mi\n"
	"	F 		: 3,	// Fa\n"
	"	S 		: 4,	// Sol\n"
	"	L 		: 5,	// La\n"
	"	T 		: 6,	// Ti\n"
	"	COUNT 	: 7\n"
	"};\n"
	"\n"
	"var Octave = {\n"
	"	NONE: -1,\n"
	"	2: 0,\n"
	"	3: 1,\n"
	"	4: 2, // octave 4: middle C octave\n"
	"	5: 3,\n"
	"	COUNT: 4\n"
	"};\n"
	"\n"
	"var Tempo = {\n"
	"	SLW: 0, // slow\n"
	"	MED: 1, // medium\n"
	"	FST: 2, // fast\n"
	"	XFST: 3 // extra fast (aka turbo)\n"
	"};\n"
	"\n"
	"var SquareWave = {\n"
	"	P8: 0, // pulse 1 / 8\n"
	"	P4: 1, // pulse 1 / 4\n"
	"	P2: 2, // pulse 1 / 2\n"
	"	COUNT: 3\n"
	"};\n"
	"\n"
	"var ArpeggioPattern = {\n"
	"	OFF: 0,\n"
	"	UP: 1, // ascending triad chord\n"
	"	DWN: 2, // descending triad chord\n"
	"	INT5: 3, // 5 step interval\n"
	"	INT8: 4 // 8 setp interval\n"
	"};\n"
	"\n"
	"function createWorldData() {\n"
	"	return {\n"
	"		room : {},\n"
	"		tile : {},\n"
	"		sprite : {},\n"
	"		item : {},\n"
	"		dialog : {},\n"
	"		end : {}, // pre-7.0 ending data for backwards compatibility\n"
	"		palette : { // start off with a default palette\n"
	"			\"default\" : {\n"
	"				name : \"default\",\n"
	"				colors : [[0,0,0],[255,255,255],[255,255,255]]\n"
	"			}\n"
	"		},\n"
	"		variable : {},\n"
	"		tune : {},\n"
	"		blip : {},\n"
	"		versionNumberFromComment : -1, // -1 indicates no version information found\n"
	"		fontName : defaultFontName,\n"
	"		textDirection : TextDirection.LeftToRight,\n"
	"		flags : createDefaultFlags(),\n"
	"		names : {},\n"
	"		// source data for all drawings (todo: better name?)\n"
	"		drawings : {},\n"
	"	};\n"
	"}\n"
	"\n"
	"// creates a drawing data structure with default property values for the type\n"
	"function createDrawingData(type, id) {\n"
	"	// the avatar's drawing id still uses the sprite prefix (for back compat)\n"
	"	var drwId = (type === \"AVA\" ? \"SPR\" : type) + \"_\" + id;\n"
	"\n"
	"	var drawingData = {\n"
	"		type : type,\n"
	"		id : id,\n"
	"		name : null,\n"
	"		drw : drwId,\n"
	"		col : (type === \"TIL\") ? 1 : 2, // foreground color\n"
	"		bgc : 0, // background color\n"
	"		animation : {\n"
	"			isAnimated : false,\n"
	"			frameIndex : 0,\n"
	"			frameCount : 1,\n"
	"		},\n"
	"	};\n"
	"\n"
	"	// add type specific properties\n"
	"	if (type === \"TIL\") {\n"
	"		// default null value indicates it can vary from room to room (original version)\n"
	"		drawingData.isWall = null;\n"
	"	}\n"
	"\n"
	"	if (type === \"AVA\" || type === \"SPR\") {\n"
	"		// default sprite location is \"offstage\"\n"
	"		drawingData.room = null;\n"
	"		drawingData.x = -1;\n"
	"		drawingData.y = -1;\n"
	"		drawingData.inventory = {};\n"
	"	}\n"
	"\n"
	"	if (type === \"AVA\" || type === \"SPR\" || type === \"ITM\") {\n"
	"		drawingData.dlg = null;\n"
	"		drawingData.blip = null;\n"
	"	}\n"
	"\n"
	"	return drawingData;\n"
	"}\n"
	"\n"
	"function createTuneData(id) {\n"
	"	var tuneData = {\n"
	"		id : id,\n"
	"		name : null,\n"
	"		melody : [],\n"
	"		harmony : [],\n"
	"		key: null, // a null key indicates a chromatic scale (all notes enabled)\n"
	"		tempo: Tempo.MED,\n"
	"		instrumentA : SquareWave.P2,\n"
	"		instrumentB : SquareWave.P2,\n"
	"		arpeggioPattern : ArpeggioPattern.OFF,\n"
	"	};\n"
	"	return tuneData;\n"
	"}\n"
	"\n"
	"function createTuneBarData() {\n"
	"	var bar = [];\n"
	"	for (var i = 0; i < barLength; i++) {\n"
	"		bar.push({ beats: 0, note: Note.C, octave: Octave[4] });\n"
	"	}\n"
	"	return bar;\n"
	"}\n"
	"\n"
	"function createTuneKeyData() {\n"
	"	var key = {\n"
	"		notes: [], // mapping of the solfa scale degrees to chromatic notes\n"
	"		scale: []  // list of solfa notes that are enabled for this key\n"
	"	};\n"
	"\n"
	"	// initialize notes\n"
	"	for (var i = 0; i < Solfa.COUNT; i++) {\n"
	"		key.notes.push(Note.NONE);\n"
	"	}\n"
	"\n"
	"	return key;\n"
	"}\n"
	"\n"
	"function createBlipData(id) {\n"
	"	var blipData = {\n"
	"		id: id,\n"
	"		name: null,\n"
	"		pitchA: { beats: 0, note: Note.C, octave: Octave[4] },\n"
	"		pitchB: { beats: 0, note: Note.C, octave: Octave[4] },\n"
	"		pitchC: { beats: 0, note: Note.C, octave: Octave[4] },\n"
	"		envelope: {\n"
	"			attack: 0, // attack time in ms\n"
	"			decay: 0, // decay time in ms\n"
	"			sustain: 0, // sustain volume\n"
	"			length: 0, // sustain time in ms\n"
	"			release: 0 // release time in ms\n"
	"		},\n"
	"		beat : {\n"
	"			time: 0, // time in ms between pitch changes\n"
	"			delay: 0 // time in ms *before* first pitch change\n"
	"		},\n"
	"		instrument: SquareWave.P2,\n"
	"		doRepeat: false\n"
	"		// TODO : consider for future update\n"
	"		// doSlide: false,\n"
	"	};\n"
	"\n"
	"	return blipData;\n"
	"}\n"
	"\n"
	"function createDefaultFlags() {\n"
	"	return {\n"
	"		// version\n"
	"		VER_MAJ: -1, // major version number (-1 = no version information found)\n"
	"		VER_MIN: -1, // minor version number (-1 = no version information found)\n"
	"		// compatibility\n"
	"		ROOM_FORMAT: 0, // 0 = non-comma separated (original), 1 = comma separated (default)\n"
	"		DLG_COMPAT: 0, // 0 = default dialog behavior, 1 = pre-7.0 dialog behavior\n"
	"		// config\n"
	"		TXT_MODE: 0 // 0 = HIREZ (2x - default), 1 = LOREZ (1x)\n"
	"	};\n"
	"}\n"
	"\n"
	"function createDialogData(id) {\n"
	"	return {\n"
	"		src : \"\",\n"
	"		name : null,\n"
	"		id : id,\n"
	"	};\n"
	"}\n"
	"\n"
	"function parseWorld(file) {\n"
	"	bitsy.log(\"create world data\");\n"
	"\n"
	"	var world = createWorldData();\n"
	"\n"
	"	bitsy.log(\"init parse state\");\n"
	"\n"
	"	var parseState = {\n"
	"		lines : file.split(\"\\n\"),\n"
	"		index : 0,\n"
	"		spriteStartLocations : {}\n"
	"	};\n"
	"\n"
	"	bitsy.log(\"start reading lines\");\n"
	"\n"
	"	while (parseState.index < parseState.lines.length) {\n"
	"		var i = parseState.index;\n"
	"		var lines = parseState.lines;\n"
	"		var curLine = lines[i];\n"
	"\n"
	"		// bitsy.log(\"LN \" + i + \" xx \" + curLine);\n"
	"\n"
	"		if (i == 0) {\n"
	"			i = parseTitle(parseState, world);\n"
	"		}\n"
	"		else if (curLine.length <= 0 || curLine.charAt(0) === \"#\") {\n"
	"			// collect version number from a comment (hacky but required for pre-8.0 compatibility)\n"
	"			if (curLine.indexOf(\"# BITSY VERSION \") != -1) {\n"
	"				world.versionNumberFromComment = parseFloat(curLine.replace(\"# BITSY VERSION \", \"\"));\n"
	"			}\n"
	"\n"
	"			//skip blank lines & comments\n"
	"			i++;\n"
	"		}\n"
	"		else if (getType(curLine) === \"PAL\") {\n"
	"			i = parsePalette(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"ROOM\" || getType(curLine) === \"SET\") { // SET for back compat\n"
	"			i = parseRoom(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"TIL\") {\n"
	"			i = parseTile(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"SPR\") {\n"
	"			i = parseSprite(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"ITM\") {\n"
	"			i = parseItem(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"DLG\") {\n"
	"			i = parseDialog(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"END\") {\n"
	"			// parse endings for back compat\n"
	"			i = parseEnding(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"VAR\") {\n"
	"			i = parseVariable(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"DEFAULT_FONT\") {\n"
	"			i = parseFontName(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"TEXT_DIRECTION\") {\n"
	"			i = parseTextDirection(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"FONT\") {\n"
	"			i = parseFontData(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"TUNE\") {\n"
	"			i = parseTune(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"BLIP\") {\n"
	"			i = parseBlip(parseState, world);\n"
	"		}\n"
	"		else if (getType(curLine) === \"!\") {\n"
	"			i = parseFlag(parseState, world);\n"
	"		}\n"
	"		else {\n"
	"			i++;\n"
	"		}\n"
	"\n"
	"		parseState.index = i;\n"
	"	}\n"
	"\n"
	"	world.names = createNameMapsForWorld(world);\n"
	"\n"
	"	placeSprites(parseState, world);\n"
	"\n"
	"	if ((world.flags.VER_MAJ <= -1 || world.flags.VER_MIN <= -1) && world.versionNumberFromComment > -1) {\n"
	"		var versionNumberStr = \"\" + world.versionNumberFromComment;\n"
	"		versionNumberStr = versionNumberStr.split(\".\");\n"
	"		world.flags.VER_MAJ = parseFloat(versionNumberStr[0]);\n"
	"		world.flags.VER_MIN = parseFloat(versionNumberStr[1]);\n"
	"	}\n"
	"\n"
	"	// starting in version v7.0, there were two major changes to dialog behavior:\n"
	"	// 1) sprite dialog was no longer implicitly linked by the sprite and dialog IDs matching\n"
	"	//    (see this commit: 5e1adb29faad4e50603c689d2dac143074117b4e)\n"
	"	// 2) ending dialogs no longer had their own world data type (\"END\")\n"
	"	// for the v7.x versions I tried to automatically convert old dialog to the new format,\n"
	"	// however, that process can be unreliable and lead to weird bugs.\n"
	"	// with v8.0 and above I will no longer attempt to convert old files, and instead will use\n"
	"	// a flag to indicate files that need to use the backwards compatible behavior -\n"
	"	// this is more reliable & configurable (at the cost of making pre-7.0 games a bit harder to edit)\n"
	"	if (world.flags.VER_MAJ < 7) {\n"
	"		world.flags.DLG_COMPAT = 1;\n"
	"	}\n"
	"\n"
	"	return world;\n"
	"}\n"
	"\n"
	"function parseTitle(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	var results;\n"
	"	if (scriptUtils) {\n"
	"		results = scriptUtils.ReadDialogScript(lines,i);\n"
	"	}\n"
	"	else {\n"
	"		results = { script: lines[i], index: (i + 1) };\n"
	"	}\n"
	"\n"
	"	world.dialog[titleDialogId] = createDialogData(titleDialogId);\n"
	"	world.dialog[titleDialogId].src = results.script;\n"
	"\n"
	"	i = results.index;\n"
	"	i++;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parsePalette(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	var id = getId(lines[i]);\n"
	"	i++;\n"
	"	var colors = [];\n"
	"	var name = null;\n"
	"	while (i < lines.length && lines[i].length > 0) { //look for empty line\n"
	"		var args = lines[i].split(\" \");\n"
	"		if (args[0] === \"NAME\") {\n"
	"			name = lines[i].split(/\\s(.+)/)[1];\n"
	"		}\n"
	"		else {\n"
	"			var col = [];\n"
	"			lines[i].split(\",\").forEach(function(i) {\n"
	"				col.push(parseInt(i));\n"
	"			});\n"
	"			colors.push(col);\n"
	"		}\n"
	"		i++;\n"
	"	}\n"
	"	world.palette[id] = {\n"
	"		id : id,\n"
	"		name : name,\n"
	"		colors : colors\n"
	"	};\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function createRoomData(id) {\n"
	"	return {\n"
	"		id: id,\n"
	"		name: null,\n"
	"		tilemap: [],\n"
	"		walls: [],\n"
	"		exits: [],\n"
	"		endings: [],\n"
	"		items: [],\n"
	"		pal: null,\n"
	"		ava: null,\n"
	"		tune: \"0\"\n"
	"	};\n"
	"}\n"
	"\n"
	"function createExitData(x, y, destRoom, destX, destY, transition, dlg) {\n"
	"	return {\n"
	"		x: x,\n"
	"		y: y,\n"
	"		dest: {\n"
	"			room: destRoom,\n"
	"			x: destX,\n"
	"			y: destY\n"
	"		},\n"
	"		transition_effect: transition,\n"
	"		dlg: dlg,\n"
	"	};\n"
	"}\n"
	"\n"
	"function createEndingData(id, x, y) {\n"
	"	return {\n"
	"		id: id,\n"
	"		x: x,\n"
	"		y: y\n"
	"	};\n"
	"}\n"
	"\n"
	"function parseRoom(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"	var id = getId(lines[i]);\n"
	"\n"
	"	var roomData = createRoomData(id);\n"
	"\n"
	"	i++;\n"
	"\n"
	"	// create tile map\n"
	"	if (world.flags.ROOM_FORMAT === 0) {\n"
	"		// old way: no commas, single char tile ids\n"
	"		var end = i + bitsy.MAP_SIZE;\n"
	"		var y = 0;\n"
	"		for (; i < end; i++) {\n"
	"			roomData.tilemap.push([]);\n"
	"			for (x = 0; x < bitsy.MAP_SIZE; x++) {\n"
	"				roomData.tilemap[y].push(lines[i].charAt(x));\n"
	"			}\n"
	"			y++;\n"
	"		}\n"
	"	}\n"
	"	else if (world.flags.ROOM_FORMAT === 1) {\n"
	"		// new way: comma separated, multiple char tile ids\n"
	"		var end = i + bitsy.MAP_SIZE;\n"
	"		var y = 0;\n"
	"		for (; i < end; i++) {\n"
	"			roomData.tilemap.push([]);\n"
	"			var lineSep = lines[i].split(\",\");\n"
	"			for (x = 0; x < bitsy.MAP_SIZE; x++) {\n"
	"				roomData.tilemap[y].push(lineSep[x]);\n"
	"			}\n"
	"			y++;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	while (i < lines.length && lines[i].length > 0) { //look for empty line\n"
	"		// bitsy.log(getType(lines[i]));\n"
	"		if (getType(lines[i]) === \"SPR\") {\n"
	"			/* NOTE SPRITE START LOCATIONS */\n"
	"			var sprId = getId(lines[i]);\n"
	"			if (sprId.indexOf(\",\") == -1 && lines[i].split(\" \").length >= 3) { //second conditional checks for coords\n"
	"				/* PLACE A SINGLE SPRITE */\n"
	"				var sprCoord = lines[i].split(\" \")[2].split(\",\");\n"
	"				parseState.spriteStartLocations[sprId] = {\n"
	"					room : id,\n"
	"					x : parseInt(sprCoord[0]),\n"
	"					y : parseInt(sprCoord[1])\n"
	"				};\n"
	"			}\n"
	"			else if ( world.flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format\n"
	"				/* PLACE MULTIPLE SPRITES*/ \n"
	"				//Does find and replace in the tilemap (may be hacky, but its convenient)\n"
	"				var sprList = sprId.split(\",\");\n"
	"				for (row in roomData.tilemap) {\n"
	"					for (s in sprList) {\n"
	"						var col = roomData.tilemap[row].indexOf( sprList[s] );\n"
	"						//if the sprite is in this row, replace it with the \"null tile\" and set its starting position\n"
	"						if (col != -1) {\n"
	"							roomData.tilemap[row][col] = \"0\";\n"
	"							parseState.spriteStartLocations[ sprList[s] ] = {\n"
	"								room : id,\n"
	"								x : parseInt(col),\n"
	"								y : parseInt(row)\n"
	"							};\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"ITM\") {\n"
	"			var itmId = getId(lines[i]);\n"
	"			var itmCoord = lines[i].split(\" \")[2].split(\",\");\n"
	"			var itm = {\n"
	"				id: itmId,\n"
	"				x : parseInt(itmCoord[0]),\n"
	"				y : parseInt(itmCoord[1])\n"
	"			};\n"
	"			roomData.items.push( itm );\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"WAL\") {\n"
	"			/* DEFINE COLLISIONS (WALLS) */\n"
	"			roomData.walls = getId(lines[i]).split(\",\");\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"EXT\") {\n"
	"			/* ADD EXIT */\n"
	"			var exitArgs = lines[i].split(\" \");\n"
	"			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]\n"
	"			var exitCoords = exitArgs[1].split(\",\");\n"
	"			var destName = exitArgs[2];\n"
	"			var destCoords = exitArgs[3].split(\",\");\n"
	"			var ext = createExitData(\n"
	"				/* x 			*/ parseInt(exitCoords[0]),\n"
	"				/* y 			*/ parseInt(exitCoords[1]),\n"
	"				/* destRoom 	*/ destName,\n"
	"				/* destX 		*/ parseInt(destCoords[0]),\n"
	"				/* destY 		*/ parseInt(destCoords[1]),\n"
	"				/* transition 	*/ null,\n"
	"				/* dlg 			*/ null);\n"
	"\n"
	"			// optional arguments\n"
	"			var exitArgIndex = 4;\n"
	"			while (exitArgIndex < exitArgs.length) {\n"
	"				if (exitArgs[exitArgIndex] == \"FX\") {\n"
	"					ext.transition_effect = exitArgs[exitArgIndex+1];\n"
	"					exitArgIndex += 2;\n"
	"				}\n"
	"				else if (exitArgs[exitArgIndex] == \"DLG\") {\n"
	"					ext.dlg = exitArgs[exitArgIndex+1];\n"
	"					exitArgIndex += 2;\n"
	"				}\n"
	"				else {\n"
	"					exitArgIndex += 1;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			roomData.exits.push(ext);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"END\") {\n"
	"			/* ADD ENDING */\n"
	"			var endId = getId(lines[i]);\n"
	"\n"
	"			var endCoords = getCoord(lines[i], 2);\n"
	"			var end = createEndingData(\n"
	"				/* id */ endId,\n"
	"				/* x */ parseInt(endCoords[0]),\n"
	"				/* y */ parseInt(endCoords[1]));\n"
	"\n"
	"			roomData.endings.push(end);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"PAL\") {\n"
	"			/* CHOOSE PALETTE (that's not default) */\n"
	"			roomData.pal = getId(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"AVA\") {\n"
	"			// change avatar appearance per room\n"
	"			roomData.ava = getId(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"TUNE\") {\n"
	"			roomData.tune = getId(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			roomData.name = getNameArg(lines[i]);\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	world.room[id] = roomData;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseTile(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	var id = getId(lines[i]);\n"
	"	var tileData = createDrawingData(\"TIL\", id);\n"
	"\n"
	"	i++;\n"
	"\n"
	"	// read & store tile image source\n"
	"	i = parseDrawingCore(lines, i, tileData.drw, world);\n"
	"\n"
	"	// update animation info\n"
	"	tileData.animation.frameCount = getDrawingFrameCount(world, tileData.drw);\n"
	"	tileData.animation.isAnimated = tileData.animation.frameCount > 1;\n"
	"\n"
	"	// read other properties\n"
	"	while (i < lines.length && lines[i].length > 0) { // look for empty line\n"
	"		if (getType(lines[i]) === \"COL\") {\n"
	"			tileData.col = parseInt(getId(lines[i]));\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"BGC\") {\n"
	"			var bgcId = getId(lines[i]);\n"
	"			if (bgcId === \"*\") {\n"
	"				// transparent background\n"
	"				tileData.bgc = (-1 * tileColorStartIndex);\n"
	"			}\n"
	"			else {\n"
	"				tileData.bgc = parseInt(bgcId);\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			/* NAME */\n"
	"			tileData.name = getNameArg(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"WAL\") {\n"
	"			var wallArg = getArg(lines[i], 1);\n"
	"			if (wallArg === \"true\") {\n"
	"				tileData.isWall = true;\n"
	"			}\n"
	"			else if (wallArg === \"false\") {\n"
	"				tileData.isWall = false;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	// store tile data\n"
	"	world.tile[id] = tileData;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseSprite(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	var id = getId(lines[i]);\n"
	"	var type = (id === \"A\") ? \"AVA\" : \"SPR\";\n"
	"	var spriteData = createDrawingData(type, id);\n"
	"\n"
	"	// bitsy.log(spriteData);\n"
	"\n"
	"	i++;\n"
	"\n"
	"	// read & store sprite image source\n"
	"	i = parseDrawingCore(lines, i, spriteData.drw, world);\n"
	"\n"
	"	// update animation info\n"
	"	spriteData.animation.frameCount = getDrawingFrameCount(world, spriteData.drw);\n"
	"	spriteData.animation.isAnimated = spriteData.animation.frameCount > 1;\n"
	"\n"
	"	// read other properties\n"
	"	while (i < lines.length && lines[i].length > 0) { // look for empty line\n"
	"		if (getType(lines[i]) === \"COL\") {\n"
	"			/* COLOR OFFSET INDEX */\n"
	"			spriteData.col = parseInt(getId(lines[i]));\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"BGC\") {\n"
	"			/* BACKGROUND COLOR */\n"
	"			var bgcId = getId(lines[i]);\n"
	"			if (bgcId === \"*\") {\n"
	"				// transparent background\n"
	"				spriteData.bgc = (-1 * tileColorStartIndex);\n"
	"			}\n"
	"			else {\n"
	"				spriteData.bgc = parseInt(bgcId);\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"POS\") {\n"
	"			/* STARTING POSITION */\n"
	"			var posArgs = lines[i].split(\" \");\n"
	"			var roomId = posArgs[1];\n"
	"			var coordArgs = posArgs[2].split(\",\");\n"
	"			parseState.spriteStartLocations[id] = {\n"
	"				room : roomId,\n"
	"				x : parseInt(coordArgs[0]),\n"
	"				y : parseInt(coordArgs[1])\n"
	"			};\n"
	"		}\n"
	"		else if(getType(lines[i]) === \"DLG\") {\n"
	"			spriteData.dlg = getId(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			/* NAME */\n"
	"			spriteData.name = getNameArg(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"ITM\") {\n"
	"			/* ITEM STARTING INVENTORY */\n"
	"			var itemId = getId(lines[i]);\n"
	"			var itemCount = parseFloat(getArg(lines[i], 2));\n"
	"			spriteData.inventory[itemId] = itemCount;\n"
	"		}\n"
	"		else if (getType(lines[i]) == \"BLIP\") {\n"
	"			var blipId = getId(lines[i]);\n"
	"			spriteData.blip = blipId;\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	// store sprite data\n"
	"	world.sprite[id] = spriteData;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseItem(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	var id = getId(lines[i]);\n"
	"	var itemData = createDrawingData(\"ITM\", id);\n"
	"\n"
	"	i++;\n"
	"\n"
	"	// read & store item image source\n"
	"	i = parseDrawingCore(lines, i, itemData.drw, world);\n"
	"\n"
	"	// update animation info\n"
	"	itemData.animation.frameCount = getDrawingFrameCount(world, itemData.drw);\n"
	"	itemData.animation.isAnimated = itemData.animation.frameCount > 1;\n"
	"\n"
	"	// read other properties\n"
	"	while (i < lines.length && lines[i].length > 0) { // look for empty line\n"
	"		if (getType(lines[i]) === \"COL\") {\n"
	"			/* COLOR OFFSET INDEX */\n"
	"			itemData.col = parseInt(getArg(lines[i], 1));\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"BGC\") {\n"
	"			/* BACKGROUND COLOR */\n"
	"			var bgcId = getId(lines[i]);\n"
	"			if (bgcId === \"*\") {\n"
	"				// transparent background\n"
	"				itemData.bgc = (-1 * tileColorStartIndex);\n"
	"			}\n"
	"			else {\n"
	"				itemData.bgc = parseInt(bgcId);\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"DLG\") {\n"
	"			itemData.dlg = getId(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			/* NAME */\n"
	"			itemData.name = getNameArg(lines[i]);\n"
	"		}\n"
	"		else if (getType(lines[i]) == \"BLIP\") {\n"
	"			var blipId = getId(lines[i]);\n"
	"			itemData.blip = blipId;\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	// store item data\n"
	"	world.item[id] = itemData;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseDrawingCore(lines, i, drwId, world) {\n"
	"	var frameList = []; //init list of frames\n"
	"	frameList.push( [] ); //init first frame\n"
	"	var frameIndex = 0;\n"
	"	var y = 0;\n"
	"	while (y < bitsy.TILE_SIZE) {\n"
	"		var line = lines[i + y];\n"
	"		var row = [];\n"
	"\n"
	"		for (x = 0; x < bitsy.TILE_SIZE; x++) {\n"
	"			row.push(parseInt(line.charAt(x)));\n"
	"		}\n"
	"\n"
	"		frameList[frameIndex].push(row);\n"
	"		y++;\n"
	"\n"
	"		if (y === bitsy.TILE_SIZE) {\n"
	"			i = i + y;\n"
	"			if (lines[i] != undefined && lines[i].charAt(0) === \">\") {\n"
	"				// start next frame!\n"
	"				frameList.push([]);\n"
	"				frameIndex++;\n"
	"\n"
	"				//start the count over again for the next frame\n"
	"				i++;\n"
	"				y = 0;\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	storeDrawingData(world, drwId, frameList);\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseDialog(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	// hacky but I need to store this so I can set the name below\n"
	"	var id = getId(lines[i]);\n"
	"\n"
	"	i = parseScript(lines, i, world.dialog);\n"
	"\n"
	"	if (i < lines.length && lines[i].length > 0 && getType(lines[i]) === \"NAME\") {\n"
	"		world.dialog[id].name = getNameArg(lines[i]);\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"// keeping this around to parse old files where endings were separate from dialogs\n"
	"function parseEnding(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	return parseScript(lines, i, world.end);\n"
	"}\n"
	"\n"
	"function parseScript(lines, i, data) {\n"
	"	var id = getId(lines[i]);\n"
	"	i++;\n"
	"\n"
	"	var results;\n"
	"	if (scriptUtils) {\n"
	"		results = scriptUtils.ReadDialogScript(lines,i);\n"
	"	}\n"
	"	else {\n"
	"		results = { script: lines[i], index: (i + 1)};\n"
	"	}\n"
	"\n"
	"	data[id] = createDialogData(id);\n"
	"	data[id].src = results.script;\n"
	"\n"
	"	i = results.index;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseVariable(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"	var id = getId(lines[i]);\n"
	"	i++;\n"
	"	var value = lines[i];\n"
	"	i++;\n"
	"	world.variable[id] = value;\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseFontName(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"	world.fontName = getArg(lines[i], 1);\n"
	"	i++;\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseTextDirection(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"	world.textDirection = getArg(lines[i], 1);\n"
	"	i++;\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseFontData(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	// NOTE : we're not doing the actual parsing here --\n"
	"	// just grabbing the block of text that represents the font\n"
	"	// and giving it to the font manager to use later\n"
	"\n"
	"	var localFontName = getId(lines[i]);\n"
	"	var localFontData = lines[i];\n"
	"	i++;\n"
	"\n"
	"	while (i < lines.length && lines[i] != \"\") {\n"
	"		localFontData += \"\\n\" + lines[i];\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	var localFontFilename = localFontName + fontManager.GetExtension();\n"
	"	fontManager.AddResource( localFontFilename, localFontData );\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseTune(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	var id = getId(lines[i]);\n"
	"	i++;\n"
	"\n"
	"	var tuneData = createTuneData(id);\n"
	"\n"
	"	var barIndex = 0;\n"
	"	while (barIndex < maxTuneLength) {\n"
	"		// MELODY\n"
	"		var melodyBar = createTuneBarData();\n"
	"		var melodyNotes = lines[i].split(\",\");\n"
	"		for (var j = 0; j < barLength; j++) {\n"
	"			// default to a rest\n"
	"			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };\n"
	"\n"
	"			if (j < melodyNotes.length) {\n"
	"				var pitchSplit = melodyNotes[j].split(\"~\");\n"
	"				var pitchStr = pitchSplit[0];\n"
	"				pitch = parsePitch(melodyNotes[j]);\n"
	"\n"
	"				// look for effect added to the note\n"
	"				if (pitchSplit.length > 1) {\n"
	"					var blipId = pitchSplit[1];\n"
	"					pitch.blip = blipId;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			melodyBar[j] = pitch;\n"
	"		}\n"
	"		tuneData.melody.push(melodyBar);\n"
	"		i++;\n"
	"\n"
	"		// HARMONY\n"
	"		var harmonyBar = createTuneBarData();\n"
	"		var harmonyNotes = lines[i].split(\",\");\n"
	"		for (var j = 0; j < barLength; j++) {\n"
	"			// default to a rest\n"
	"			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };\n"
	"\n"
	"			if (j < harmonyNotes.length) {\n"
	"				var pitchSplit = harmonyNotes[j].split(\"~\");\n"
	"				var pitchStr = pitchSplit[0];\n"
	"				pitch = parsePitch(harmonyNotes[j]);\n"
	"\n"
	"				// look for effect added to the note\n"
	"				if (pitchSplit.length > 1) {\n"
	"					var blipId = pitchSplit[1];\n"
	"					pitch.blip = blipId;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			harmonyBar[j] = pitch;\n"
	"		}\n"
	"		tuneData.harmony.push(harmonyBar);\n"
	"		i++;\n"
	"\n"
	"		// check if there's another bar after this one\n"
	"		if (lines[i] === \">\") {\n"
	"			// there is! increment the index\n"
	"			barIndex++;\n"
	"			i++;\n"
	"		}\n"
	"		else {\n"
	"			// we've reached the end of the tune!\n"
	"			barIndex = maxTuneLength;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// parse other tune properties\n"
	"	while (i < lines.length && lines[i].length > 0) { // look for empty line\n"
	"		if (getType(lines[i]) === \"KEY\") {\n"
	"			tuneData.key = createTuneKeyData();\n"
	"\n"
	"			var keyNotes = getArg(lines[i], 1);\n"
	"			if (keyNotes) {\n"
	"				keyNotes = keyNotes.split(\",\");\n"
	"				for (var j = 0; j < keyNotes.length && j < tuneData.key.notes.length; j++) {\n"
	"					var pitch = parsePitch(keyNotes[j]);\n"
	"					tuneData.key.notes[j] = pitch.note;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			var keyScale = getArg(lines[i], 2);\n"
	"			if (keyScale) {\n"
	"				keyScale = keyScale.split(\",\");\n"
	"				for (var j = 0; j < keyScale.length; j++) {\n"
	"					var pitch = parsePitch(keyScale[j]);\n"
	"					if (pitch.note > Solfa.NONE && pitch.note < Solfa.COUNT) {\n"
	"						tuneData.key.scale.push(pitch.note);\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"TMP\") {\n"
	"			var tempoId = getId(lines[i]);\n"
	"			if (Tempo[tempoId] != undefined) {\n"
	"				tuneData.tempo = Tempo[tempoId];\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"SQR\") {\n"
	"			// square wave instrument settings\n"
	"			var squareWaveIdA = getArg(lines[i], 1);\n"
	"			if (SquareWave[squareWaveIdA] != undefined) {\n"
	"				tuneData.instrumentA = SquareWave[squareWaveIdA];\n"
	"			}\n"
	"\n"
	"			var squareWaveIdB = getArg(lines[i], 2);\n"
	"			if (SquareWave[squareWaveIdB] != undefined) {\n"
	"				tuneData.instrumentB = SquareWave[squareWaveIdB];\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"ARP\") {\n"
	"			var arp = getId(lines[i]);\n"
	"			if (ArpeggioPattern[arp] != undefined) {\n"
	"				tuneData.arpeggioPattern = ArpeggioPattern[arp];\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			var name = lines[i].split(/\\s(.+)/)[1];\n"
	"			tuneData.name = name;\n"
	"			// todo : add to map?\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	world.tune[id] = tuneData;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parseBlip(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"\n"
	"	var id = getId(lines[i]);\n"
	"	i++;\n"
	"\n"
	"	var blipData = createBlipData(id);\n"
	"\n"
	"	// blip pitches\n"
	"	var notes = lines[i].split(\",\");\n"
	"	if (notes.length >= 1) {\n"
	"		blipData.pitchA = parsePitch(notes[0]);\n"
	"	}\n"
	"	if (notes.length >= 2) {\n"
	"		blipData.pitchB = parsePitch(notes[1]);\n"
	"	}\n"
	"	if (notes.length >= 3) {\n"
	"		blipData.pitchC = parsePitch(notes[2]);\n"
	"	}\n"
	"	i++;\n"
	"\n"
	"	// blip parameters\n"
	"	while (i < lines.length && lines[i].length > 0) { // look for empty line\n"
	"		if (getType(lines[i]) === \"ENV\") {\n"
	"			// envelope\n"
	"			blipData.envelope.attack = parseInt(getArg(lines[i], 1));\n"
	"			blipData.envelope.decay = parseInt(getArg(lines[i], 2));\n"
	"			blipData.envelope.sustain = parseInt(getArg(lines[i], 3));\n"
	"			blipData.envelope.length = parseInt(getArg(lines[i], 4));\n"
	"			blipData.envelope.release = parseInt(getArg(lines[i], 5));\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"BEAT\") {\n"
	"			// pitch beat length\n"
	"			blipData.beat.time = parseInt(getArg(lines[i], 1));\n"
	"			blipData.beat.delay = parseInt(getArg(lines[i], 2));\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"SQR\") {\n"
	"			// square wave\n"
	"			var squareWaveId = getArg(lines[i], 1);\n"
	"			if (SquareWave[squareWaveId] != undefined) {\n"
	"				blipData.instrument = SquareWave[squareWaveId];\n"
	"			}\n"
	"		}\n"
	"		// TODO : consider for future update\n"
	"		// else if (getType(lines[i]) === \"SLD\") {\n"
	"		// 	// slide mode\n"
	"		// 	if (parseInt(getArg(lines[i], 1)) === 1) {\n"
	"		// 		blipData.doSlide = true;\n"
	"		// 	}\n"
	"		// }\n"
	"		else if (getType(lines[i]) === \"RPT\") {\n"
	"			// repeat mode\n"
	"			if (parseInt(getArg(lines[i], 1)) === 1) {\n"
	"				blipData.doRepeat = true;\n"
	"			}\n"
	"		}\n"
	"		else if (getType(lines[i]) === \"NAME\") {\n"
	"			var name = lines[i].split(/\\s(.+)/)[1];\n"
	"			blipData.name = name;\n"
	"		}\n"
	"\n"
	"		i++;\n"
	"	}\n"
	"\n"
	"	world.blip[id] = blipData;\n"
	"\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function parsePitch(pitchStr) {\n"
	"	var pitch = { beats: 1, note: Note.C, octave: Octave[4], };\n"
	"	var i;\n"
	"\n"
	"	// beats\n"
	"	var beatsToken = \"\";\n"
	"	for (i = 0; i < pitchStr.length && (\"0123456789\".indexOf(pitchStr[i]) != -1); i++) {\n"
	"		beatsToken += pitchStr[i];\n"
	"	}\n"
	"	if (beatsToken.length > 0) {\n"
	"		pitch.beats = parseInt(beatsToken);\n"
	"	}\n"
	"\n"
	"	// note\n"
	"	var noteType;\n"
	"	var noteName = \"\";\n"
	"	if (i < pitchStr.length) {\n"
	"		if (pitchStr[i] === pitchStr[i].toUpperCase()) {\n"
	"			// uppercase letters represent chromatic notes\n"
	"			noteType = Note;\n"
	"			noteName += pitchStr[i];\n"
	"			i++;\n"
	"\n"
	"			// check for sharp\n"
	"			if (i < pitchStr.length && pitchStr[i] === \"#\") {\n"
	"				noteName += \"_SHARP\";\n"
	"				i++;\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			// lowercase letters represent solfa notes\n"
	"			noteType = Solfa;\n"
	"			noteName += pitchStr[i].toUpperCase();\n"
	"			i++;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if (noteType != undefined && noteType[noteName] != undefined) {\n"
	"		pitch.note = noteType[noteName];\n"
	"	}\n"
	"\n"
	"	// octave\n"
	"	var octaveToken = \"\";\n"
	"	if (i < pitchStr.length) {\n"
	"		octaveToken += pitchStr[i];\n"
	"	}\n"
	"\n"
	"	if (Octave[octaveToken] != undefined) {\n"
	"		pitch.octave = Octave[octaveToken];\n"
	"	}\n"
	"\n"
	"	return pitch;\n"
	"}\n"
	"\n"
	"function parseFlag(parseState, world) {\n"
	"	var i = parseState.index;\n"
	"	var lines = parseState.lines;\n"
	"	var id = getId(lines[i]);\n"
	"	var valStr = lines[i].split(\" \")[2];\n"
	"	world.flags[id] = parseInt( valStr );\n"
	"	i++;\n"
	"	return i;\n"
	"}\n"
	"\n"
	"function getDrawingFrameCount(world, drwId) {\n"
	"	return world.drawings[drwId].length;\n"
	"}\n"
	"\n"
	"function storeDrawingData(world, drwId, drawingData) {\n"
	"	world.drawings[drwId] = drawingData;\n"
	"}\n"
	"\n"
	"function placeSprites(parseState, world) {\n"
	"	for (id in parseState.spriteStartLocations) {\n"
	"		world.sprite[id].room = parseState.spriteStartLocations[id].room;\n"
	"		world.sprite[id].x = parseState.spriteStartLocations[id].x;\n"
	"		world.sprite[id].y = parseState.spriteStartLocations[id].y;\n"
	"	}\n"
	"}\n"
	"\n"
	"function createNameMapsForWorld(world) {\n"
	"	var nameMaps = {};\n"
	"\n"
	"	function createNameMap(objectStore) {\n"
	"		var map = {};\n"
	"\n"
	"		for (id in objectStore) {\n"
	"			if (objectStore[id].name != undefined && objectStore[id].name != null) {\n"
	"				map[objectStore[id].name] = id;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		return map;\n"
	"	}\n"
	"\n"
	"	nameMaps.room = createNameMap(world.room);\n"
	"	nameMaps.tile = createNameMap(world.tile);\n"
	"	nameMaps.sprite = createNameMap(world.sprite);\n"
	"	nameMaps.item = createNameMap(world.item);\n"
	"	nameMaps.dialog = createNameMap(world.dialog);\n"
	"	nameMaps.palette = createNameMap(world.palette);\n"
	"	nameMaps.tune = createNameMap(world.tune);\n"
	"	nameMaps.blip = createNameMap(world.blip);\n"
	"\n"
	"	return nameMaps;\n"
	"}\n"
	"\n"
	"function getType(line) {\n"
	"	return getArg(line,0);\n"
	"}\n"
	"\n"
	"function getId(line) {\n"
	"	return getArg(line,1);\n"
	"}\n"
	"\n"
	"function getCoord(line,arg) {\n"
	"	return getArg(line,arg).split(\",\");\n"
	"}\n"
	"\n"
	"function getArg(line,arg) {\n"
	"	return line.split(\" \")[arg];\n"
	"}\n"
	"\n"
	"function getNameArg(line) {\n"
	"	var name = line.split(/\\s(.+)/)[1];\n"
	"	return name;\n"
	"}\n";

char* dialog_js =
	"function Dialog() {\n"
	"\n"
	"this.CreateRenderer = function() {\n"
	"	return new DialogRenderer();\n"
	"};\n"
	"\n"
	"this.CreateBuffer = function() {\n"
	"	return new DialogBuffer();\n"
	"};\n"
	"\n"
	"var DialogRenderer = function() {\n"
	"	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?\n"
	"	var textboxInfo = {\n"
	"		width : 104,\n"
	"		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow\n"
	"		top : 12,\n"
	"		left : 12,\n"
	"		bottom : 12, //for drawing it from the bottom\n"
	"		padding_vert : 2,\n"
	"		padding_horz : 4,\n"
	"		arrow_height : 5,\n"
	"	};\n"
	"\n"
	"	var font = null;\n"
	"	this.SetFont = function(f) {\n"
	"		font = f;\n"
	"		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;\n"
	"\n"
	"		// todo : clean up all the scale stuff\n"
	"		var textboxScaleW = textboxInfo.width * getTextScale();\n"
	"		var textboxScaleH = textboxInfo.height * getTextScale();\n"
	"		bitsy.textbox(false, 0, 0, textboxScaleW, textboxScaleH);\n"
	"	}\n"
	"\n"
	"	this.GetPixelsPerRow = function() {\n"
	"		return (textboxInfo.width - (textboxInfo.padding_horz * 2)) * getTextScale();\n"
	"	}\n"
	"\n"
	"	// todo : cache this value? it shouldn't really change in the middle of a game\n"
	"	function getTextScale() {\n"
	"		return bitsy.textMode() === bitsy.TXT_LOREZ ? 1 : 2;\n"
	"	}\n"
	"\n"
	"	function relativeFontWidth() {\n"
	"		return Math.ceil(font.getWidth() / getTextScale());\n"
	"	}\n"
	"\n"
	"	function relativeFontHeight() {\n"
	"		return Math.ceil(font.getHeight() / getTextScale());\n"
	"	}\n"
	"\n"
	"	this.ClearTextbox = function() {\n"
	"		bitsy.fill(bitsy.TEXTBOX, textBackgroundIndex);\n"
	"	};\n"
	"\n"
	"	var isCentered = false;\n"
	"	this.SetCentered = function(centered) {\n"
	"		isCentered = centered;\n"
	"	};\n"
	"\n"
	"	// todo : I can stop doing this every frame right?\n"
	"	this.DrawTextbox = function() {\n"
	"		if (isCentered) {\n"
	"			// todo : will the height calculations always work?\n"
	"			bitsy.textbox(true, textboxInfo.left, ((bitsy.VIDEO_SIZE / 2) - (textboxInfo.height / 2)));\n"
	"		}\n"
	"		else if (player().y < (bitsy.MAP_SIZE / 2)) {\n"
	"			// bottom\n"
	"			bitsy.textbox(true, textboxInfo.left, (bitsy.VIDEO_SIZE - textboxInfo.bottom - textboxInfo.height));\n"
	"		}\n"
	"		else {\n"
	"			// top\n"
	"			bitsy.textbox(true, textboxInfo.left, textboxInfo.top);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var arrowdata = [\n"
	"		1,1,1,1,1,\n"
	"		0,1,1,1,0,\n"
	"		0,0,1,0,0\n"
	"	];\n"
	"\n"
	"	this.DrawNextArrow = function() {\n"
	"		// bitsy.log(\"draw arrow!\");\n"
	"		var text_scale = getTextScale();\n"
	"		var textboxScaleW = textboxInfo.width * text_scale;\n"
	"		var textboxScaleH = textboxInfo.height * text_scale;\n"
	"\n"
	"		var top = (textboxInfo.height - 5) * text_scale;\n"
	"		var left = (textboxInfo.width - (5 + 4)) * text_scale;\n"
	"		if (textDirection === TextDirection.RightToLeft) { // RTL hack\n"
	"			left = 4 * text_scale;\n"
	"		}\n"
	"\n"
	"		for (var y = 0; y < 3; y++) {\n"
	"			for (var x = 0; x < 5; x++) {\n"
	"				var i = (y * 5) + x;\n"
	"				if (arrowdata[i] == 1) {\n"
	"					//scaling nonsense\n"
	"					for (var sy = 0; sy < text_scale; sy++) {\n"
	"						for (var sx = 0; sx < text_scale; sx++) {\n"
	"							var px = left + (x * text_scale) + sx;\n"
	"							var py = top + (y * text_scale) + sy;\n"
	"							bitsy.set(bitsy.TEXTBOX, (py * textboxScaleW) + px, textArrowIndex);\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	};\n"
	"\n"
	"	function drawCharData(charData, textScale, top, left, width, height, color) {\n"
	"		for (var y = 0; y < height; y++) {\n"
	"			for (var x = 0; x < width; x++) {\n"
	"				var i = (y * width) + x;\n"
	"				if (charData[i] == 1) {\n"
	"					bitsy.set(bitsy.TEXTBOX, ((top + y) * (textboxInfo.width * textScale)) + (left + x), color);\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.DrawChar = function(char, row, col, leftPos) {\n"
	"		// characters with effects need to be redrawn every frame\n"
	"		if (char.effectList.length > 0) {\n"
	"			char.redraw = true;\n"
	"		}\n"
	"\n"
	"		// skip characters that are already drawn and don't need to be updated\n"
	"		if (!char.redraw) {\n"
	"			return;\n"
	"		}\n"
	"		char.redraw = false;\n"
	"\n"
	"		var text_scale = getTextScale();\n"
	"		var charData = char.bitmap;\n"
	"		var top;\n"
	"		var left;\n"
	"\n"
	"		if (char.effectList.length > 0) {\n"
	"			// clear the pixels from the previous frame\n"
	"			top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);\n"
	"			left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);\n"
	"			drawCharData(charData, text_scale, top, left, char.width, char.height, textBackgroundIndex);\n"
	"		}\n"
	"\n"
	"		// compute render offset *every* frame\n"
	"		char.offset = {\n"
	"			x: char.base_offset.x,\n"
	"			y: char.base_offset.y\n"
	"		};\n"
	"		char.SetPosition(row, col);\n"
	"		char.ApplyEffects(effectTime);\n"
	"\n"
	"		top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);\n"
	"		left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);\n"
	"\n"
	"		drawCharData(charData, text_scale, top, left, char.width, char.height, char.color);\n"
	"\n"
	"		// TODO : consider for a future update?\n"
	"		/*\n"
	"		if (soundPlayer && char.blip && char.hasPlayedBlip != true) {\n"
	"			soundPlayer.playBlip(blip[char.blip], { isPitchRandomized: true });\n"
	"			char.hasPlayedBlip = true;\n"
	"		}\n"
	"		*/\n"
	"\n"
	"		// call printHandler for character\n"
	"		if (!disableOnPrintHandlers) {\n"
	"			char.OnPrint();\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var effectTime = 0; // TODO this variable should live somewhere better\n"
	"\n"
	"	var shouldUpdateTextboxSettings = true;\n"
	"	var shouldClearTextbox = true;\n"
	"	var shouldDrawArrow = true;\n"
	"\n"
	"	var disableOnPrintHandlers = false;\n"
	"\n"
	"	this.Draw = function(buffer, dt, disableOnPrint) {\n"
	"		disableOnPrintHandlers = (disableOnPrint === true);\n"
	"\n"
	"		// bitsy.log(\"draw dialog\");\n"
	"		if (buffer.DidFlipPageThisFrame()) {\n"
	"			shouldClearTextbox = true;\n"
	"			shouldDrawArrow = true;\n"
	"		}\n"
	"\n"
	"		effectTime += dt;\n"
	"\n"
	"		if (shouldUpdateTextboxSettings) {\n"
	"			bitsy.log(\"draw textbox\");\n"
	"			this.DrawTextbox(); // todo : rename to something more accurate\n"
	"			shouldUpdateTextboxSettings = false;\n"
	"		}\n"
	"\n"
	"		if (shouldClearTextbox) {\n"
	"			// bitsy.log(\"clear textbox\");\n"
	"			this.ClearTextbox();\n"
	"			shouldClearTextbox = false;\n"
	"		}\n"
	"\n"
	"		// bitsy.log(\"draw chars\");\n"
	"		buffer.ForEachActiveChar(this.DrawChar);\n"
	"\n"
	"		if (buffer.CanContinue() && shouldDrawArrow) {\n"
	"			// bitsy.log(\"draw next arrow\");\n"
	"			this.DrawNextArrow();\n"
	"			shouldDrawArrow = false;\n"
	"		}\n"
	"\n"
	"		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {\n"
	"			bitsy.log(\"page finished\");\n"
	"			onPageFinish();\n"
	"		}\n"
	"\n"
	"		// bitsy.log(\"draw dialog end\");\n"
	"	};\n"
	"\n"
	"	/* this is a hook for GIF rendering */\n"
	"	var onPageFinish = null;\n"
	"	this.SetPageFinishHandler = function(handler) {\n"
	"		onPageFinish = handler;\n"
	"	};\n"
	"\n"
	"	this.Reset = function() {\n"
	"		effectTime = 0;\n"
	"		// TODO - anything else?\n"
	"\n"
	"		shouldUpdateTextboxSettings = true;\n"
	"		shouldClearTextbox = true;\n"
	"		shouldDrawArrow = true;\n"
	"	}\n"
	"\n"
	"	this.updateTextboxPosition = function() {\n"
	"		shouldUpdateTextboxSettings = true;\n"
	"	};\n"
	"\n"
	"	// this.CharsPerRow = function() {\n"
	"	// 	return textboxInfo.charsPerRow;\n"
	"	// }\n"
	"}\n"
	"\n"
	"var DialogBuffer = function() {\n"
	"	var buffer = [[[]]]; // holds dialog in an array buffer\n"
	"	var pageIndex = 0;\n"
	"	var rowIndex = 0;\n"
	"	var charIndex = 0;\n"
	"	var nextCharTimer = 0;\n"
	"	var nextCharMaxTime = 50; // in milliseconds\n"
	"	var isDialogReadyToContinue = false;\n"
	"	var activeTextEffects = [];\n"
	"	var activeTextEffectParameters = [];\n"
	"	var font = null;\n"
	"	var arabicHandler = new ArabicHandler();\n"
	"	var onDialogEndCallbacks = [];\n"
	"\n"
	"	this.SetFont = function(f) {\n"
	"		font = f;\n"
	"	};\n"
	"\n"
	"	this.SetPixelsPerRow = function(n) {\n"
	"		pixelsPerRow = n;\n"
	"	};\n"
	"\n"
	"	this.CurPage = function() { return buffer[ pageIndex ]; };\n"
	"	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };\n"
	"	this.CurChar = function() { return this.CurRow()[ charIndex ]; };\n"
	"	this.CurPageCount = function() { return buffer.length; };\n"
	"	this.CurRowCount = function() { return this.CurPage().length; };\n"
	"	this.CurCharCount = function() { return this.CurRow().length; };\n"
	"\n"
	"	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page\n"
	"		var rowCount = rowIndex + 1;\n"
	"		for (var i = 0; i < rowCount; i++) {\n"
	"			var row = this.CurPage()[i];\n"
	"			var charCount = (i == rowIndex) ? charIndex+1 : row.length;\n"
	"			// bitsy.log(charCount);\n"
	"\n"
	"			var leftPos = 0;\n"
	"			if (textDirection === TextDirection.RightToLeft) {\n"
	"				leftPos = 24 * 8; // hack -- I think this is correct?\n"
	"			}\n"
	"\n"
	"			for(var j = 0; j < charCount; j++) {\n"
	"				var char = row[j];\n"
	"				if(char) {\n"
	"					if (textDirection === TextDirection.RightToLeft) {\n"
	"						leftPos -= char.spacing;\n"
	"					}\n"
	"					// bitsy.log(j + \" \" + leftPos);\n"
	"\n"
	"					// handler( char, i /*rowIndex*/, j /*colIndex*/ );\n"
	"					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)\n"
	"\n"
	"					if (textDirection === TextDirection.LeftToRight) {\n"
	"						leftPos += char.spacing;\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.Reset = function() {\n"
	"		buffer = [[[]]];\n"
	"		pageIndex = 0;\n"
	"		rowIndex = 0;\n"
	"		charIndex = 0;\n"
	"		isDialogReadyToContinue = false;\n"
	"\n"
	"		afterManualPagebreak = false;\n"
	"\n"
	"		activeTextEffects = [];\n"
	"\n"
	"		onDialogEndCallbacks = [];\n"
	"\n"
	"		isActive = false;\n"
	"	};\n"
	"\n"
	"	this.DoNextChar = function() {\n"
	"		nextCharTimer = 0; //reset timer\n"
	"\n"
	"		//time to update characters\n"
	"		if (charIndex + 1 < this.CurCharCount()) {\n"
	"			//add char to current row\n"
	"			charIndex++;\n"
	"		}\n"
	"		else if (rowIndex + 1 < this.CurRowCount()) {\n"
	"			//start next row\n"
	"			rowIndex++;\n"
	"			charIndex = 0;\n"
	"		}\n"
	"		else {\n"
	"			//the page is full!\n"
	"			isDialogReadyToContinue = true;\n"
	"			didPageFinishThisFrame = true;\n"
	"		}\n"
	"\n"
	"		if (this.CurChar() != null) {\n"
	"			if (this.CurChar().isPageBreak) {\n"
	"				// special case for page break marker character!\n"
	"				isDialogReadyToContinue = true;\n"
	"				didPageFinishThisFrame = true;\n"
	"			}\n"
	"			\n"
	"			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.Update = function(dt) {\n"
	"		didPageFinishThisFrame = false;\n"
	"		didFlipPageThisFrame = false;\n"
	"		// this.Draw(dt); // TODO move into a renderer object\n"
	"		if (isDialogReadyToContinue) {\n"
	"			return; //waiting for dialog to be advanced by player\n"
	"		}\n"
	"\n"
	"		nextCharTimer += dt; //tick timer\n"
	"\n"
	"		if (nextCharTimer > nextCharMaxTime) {\n"
	"			this.DoNextChar();\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var isSkipping = false;\n"
	"\n"
	"	this.Skip = function() {\n"
	"		bitsy.log(\"SKIPPP\");\n"
	"		isSkipping = true;\n"
	"\n"
	"		didPageFinishThisFrame = false;\n"
	"		didFlipPageThisFrame = false;\n"
	"\n"
	"		// add new characters until you get to the end of the current line of dialog\n"
	"		while (rowIndex < this.CurRowCount() && isSkipping) {\n"
	"			this.DoNextChar();\n"
	"\n"
	"			if (isDialogReadyToContinue) {\n"
	"				//make sure to push the rowIndex past the end to break out of the loop\n"
	"				rowIndex++;\n"
	"				charIndex = 0;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		if (isSkipping) {\n"
	"			rowIndex = this.CurRowCount() - 1;\n"
	"			charIndex = this.CurCharCount() - 1;\n"
	"		}\n"
	"\n"
	"		isSkipping = false;\n"
	"	};\n"
	"\n"
	"	this.tryInterruptSkip = function() {\n"
	"		if (isSkipping) {\n"
	"			isSkipping = false;\n"
	"			return true;\n"
	"		}\n"
	"\n"
	"		return false;\n"
	"	};\n"
	"\n"
	"	this.FlipPage = function() {\n"
	"		didFlipPageThisFrame = true;\n"
	"		isDialogReadyToContinue = false;\n"
	"		pageIndex++;\n"
	"		rowIndex = 0;\n"
	"		charIndex = 0;\n"
	"	}\n"
	"\n"
	"	this.EndDialog = function() {\n"
	"		isActive = false; // no more text to show... this should be a sign to stop rendering dialog\n"
	"\n"
	"		for (var i = 0; i < onDialogEndCallbacks.length; i++) {\n"
	"			onDialogEndCallbacks[i]();\n"
	"		}\n"
	"	}\n"
	"\n"
	"	var afterManualPagebreak = false; // is it bad to track this state like this?\n"
	"\n"
	"	this.Continue = function() {\n"
	"		bitsy.log(\"CONTINUE\");\n"
	"\n"
	"		// if we used a page break character to continue we need\n"
	"		// to run whatever is in the script afterwards! // TODO : make this comment better\n"
	"		if (this.CurChar().isPageBreak) {\n"
	"			// hacky: always treat a page break as the end of dialog\n"
	"			// if there's more dialog later we re-activate the dialog buffer\n"
	"			this.EndDialog();\n"
	"			afterManualPagebreak = true;\n"
	"			this.CurChar().OnContinue();\n"
	"			return false;\n"
	"		}\n"
	"		if (pageIndex + 1 < this.CurPageCount()) {\n"
	"			bitsy.log(\"FLIP PAGE!\");\n"
	"			//start next page\n"
	"			this.FlipPage();\n"
	"			return true; /* hasMoreDialog */\n"
	"		}\n"
	"		else {\n"
	"			bitsy.log(\"END DIALOG!\");\n"
	"			bitsy.textbox(false);\n"
	"			//end dialog mode\n"
	"			this.EndDialog();\n"
	"			return false; /* hasMoreDialog */\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var isActive = false;\n"
	"	this.IsActive = function() { return isActive; };\n"
	"\n"
	"	this.OnDialogEnd = function(callback) {\n"
	"		if (!isActive) {\n"
	"			callback();\n"
	"		}\n"
	"		else {\n"
	"			onDialogEndCallbacks.push(callback);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.CanContinue = function() { return isDialogReadyToContinue; };\n"
	"\n"
	"	function DialogChar() {\n"
	"		this.redraw = true;\n"
	"\n"
	"		this.effectList = [];\n"
	"		this.effectParameterList = [];\n"
	"\n"
	"		this.color = textColorIndex; // white\n"
	"		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)\n"
	"\n"
	"		this.col = 0;\n"
	"		this.row = 0;\n"
	"\n"
	"		this.SetPosition = function(row,col) {\n"
	"			// bitsy.log(\"SET POS\");\n"
	"			// bitsy.log(this);\n"
	"			this.row = row;\n"
	"			this.col = col;\n"
	"		};\n"
	"\n"
	"		this.ApplyEffects = function(time) {\n"
	"			// bitsy.log(\"APPLY EFFECTS! \" + time);\n"
	"			for (var i = 0; i < this.effectList.length; i++) {\n"
	"				var effectName = this.effectList[i];\n"
	"				// bitsy.log(\"FX \" + effectName);\n"
	"				TextEffects[effectName].doEffect(this, time, this.effectParameterList[i]);\n"
	"			}\n"
	"		};\n"
	"\n"
	"		var printHandler = null; // optional function to be called once on printing character\n"
	"		this.SetPrintHandler = function(handler) {\n"
	"			printHandler = handler;\n"
	"		};\n"
	"		this.OnPrint = function() {\n"
	"			if (printHandler != null) {\n"
	"				// bitsy.log(\"PRINT HANDLER ---- DIALOG BUFFER\");\n"
	"				printHandler();\n"
	"				printHandler = null; // only call handler once (hacky)\n"
	"			}\n"
	"		};\n"
	"\n"
	"		this.bitmap = [];\n"
	"		this.width = 0;\n"
	"		this.height = 0;\n"
	"		this.base_offset = { // hacky name\n"
	" 			x: 0,\n"
	"			y: 0\n"
	"		};\n"
	"		this.spacing = 0;\n"
	"	}\n"
	"\n"
	"	function DialogFontChar(font, char, effectList, effectParameterList) {\n"
	"		DialogChar.call(this);\n"
	"\n"
	"		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)\n"
	"		this.effectParameterList = effectParameterList.slice();\n"
	"\n"
	"		var charData = font.getChar(char);\n"
	"		this.char = char;\n"
	"		this.bitmap = charData.data;\n"
	"		this.width = charData.width;\n"
	"		this.height = charData.height;\n"
	"		this.base_offset.x = charData.offset.x;\n"
	"		this.base_offset.y = charData.offset.y;\n"
	"		this.spacing = charData.spacing;\n"
	"		this.blip = null;\n"
	"		this.hasPlayedBlip = false;\n"
	"	}\n"
	"\n"
	"	function DialogDrawingChar(drawingId, effectList, effectParameterList) {\n"
	"		DialogChar.call(this);\n"
	"\n"
	"		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)\n"
	"		this.effectParameterList = effectParameterList.slice();\n"
	"\n"
	"		// get the first frame of the drawing and flatten it\n"
	"		var drawingData = renderer.GetDrawingSource(drawingId)[0];\n"
	"		var drawingDataFlat = [];\n"
	"		for (var i = 0; i < drawingData.length; i++) {\n"
	"			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);\n"
	"		}\n"
	"\n"
	"		this.bitmap = drawingDataFlat;\n"
	"		this.width = 8;\n"
	"		this.height = 8;\n"
	"		this.spacing = 8;\n"
	"	}\n"
	"\n"
	"	function DialogScriptControlChar() {\n"
	"		DialogChar.call(this);\n"
	"\n"
	"		this.width = 0;\n"
	"		this.height = 0;\n"
	"		this.spacing = 0;\n"
	"	}\n"
	"\n"
	"	// is a control character really the best way to handle page breaks?\n"
	"	function DialogPageBreakChar() {\n"
	"		DialogChar.call(this);\n"
	"\n"
	"		this.width = 0;\n"
	"		this.height = 0;\n"
	"		this.spacing = 0;\n"
	"\n"
	"		this.isPageBreak = true;\n"
	"\n"
	"		var continueHandler = null;\n"
	"\n"
	"		this.SetContinueHandler = function(handler) {\n"
	"			continueHandler = handler;\n"
	"		};\n"
	"\n"
	"		this.OnContinue = function() {\n"
	"			if (continueHandler) {\n"
	"				continueHandler();\n"
	"			}\n"
	"		};\n"
	"	}\n"
	"\n"
	"	function AddWordToCharArray(charArray, word, effectList, effectParameterList) {\n"
	"		// bitsy.log(\"add char array\");\n"
	"		for (var i = 0; i < word.length; i++) {\n"
	"			charArray.push(new DialogFontChar(font, word[i], effectList, effectParameterList));\n"
	"		}\n"
	"		// bitsy.log(\"add char array end\");\n"
	"		return charArray;\n"
	"	}\n"
	"\n"
	"	function GetCharArrayWidth(charArray) {\n"
	"		var width = 0;\n"
	"		for(var i = 0; i < charArray.length; i++) {\n"
	"			width += charArray[i].spacing;\n"
	"		}\n"
	"		return width;\n"
	"	}\n"
	"\n"
	"	function GetStringWidth(str) {\n"
	"		var width = 0;\n"
	"		for (var i = 0; i < str.length; i++) {\n"
	"			var charData = font.getChar(str[i]);\n"
	"			width += charData.spacing;\n"
	"		}\n"
	"		return width;\n"
	"	}\n"
	"\n"
	"	var pixelsPerRow = 192; // hard-coded fun times!!!\n"
	"\n"
	"	this.AddScriptReturn = function(onReturnHandler) {\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		var controlChar = new DialogScriptControlChar();\n"
	"		controlChar.SetPrintHandler(onReturnHandler);\n"
	"\n"
	"		curRowArr.push(controlChar);\n"
	"\n"
	"		isActive = true;\n"
	"	}\n"
	"\n"
	"	this.AddDrawing = function(drawingId) {\n"
	"		// bitsy.log(\"DRAWING ID \" + drawingId);\n"
	"\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects, activeTextEffectParameters);\n"
	"\n"
	"		var rowLength = GetCharArrayWidth(curRowArr);\n"
	"\n"
	"		// TODO : clean up copy-pasted code here :/\n"
	"		if (afterManualPagebreak) {\n"
	"			this.FlipPage(); // hacky\n"
	"\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer.push([]);\n"
	"			curPageIndex++;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex = 0;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"			curRowArr.push(drawingChar);\n"
	"\n"
	"			afterManualPagebreak = false;\n"
	"		}\n"
	"		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {\n"
	"			//stay on same row\n"
	"			curRowArr.push(drawingChar);\n"
	"		}\n"
	"		else if (curRowIndex == 0) {\n"
	"			//start next row\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex++;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"			curRowArr.push(drawingChar);\n"
	"		}\n"
	"		else {\n"
	"			//start next page\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer.push([]);\n"
	"			curPageIndex++;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex = 0;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"			curRowArr.push(drawingChar);\n"
	"		}\n"
	"\n"
	"		isActive = true; // this feels like a bad way to do this???\n"
	"	}\n"
	"\n"
	"	// TODO : convert this into something that takes DialogChar arrays\n"
	"	this.AddText = function(textStr) {\n"
	"		bitsy.log(\"ADD TEXT >>\" + textStr + \"<<\");\n"
	"\n"
	"		//process dialog so it's easier to display\n"
	"		var words = textStr.split(\" \");\n"
	"\n"
	"		// var curPageIndex = this.CurPageCount() - 1;\n"
	"		// var curRowIndex = this.CurRowCount() - 1;\n"
	"		// var curRowArr = this.CurRow();\n"
	"\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		for (var i = 0; i < words.length; i++) {\n"
	"			var word = words[i];\n"
	"			if (arabicHandler.ContainsArabicCharacters(word)) {\n"
	"				word = arabicHandler.ShapeArabicCharacters(word);\n"
	"			}\n"
	"\n"
	"			var wordWithPrecedingSpace = ((i == 0) ? \"\" : \" \") + word;\n"
	"			var wordLength = GetStringWidth(wordWithPrecedingSpace);\n"
	"\n"
	"			var rowLength = GetCharArrayWidth(curRowArr);\n"
	"\n"
	"			if (afterManualPagebreak) {\n"
	"				this.FlipPage();\n"
	"\n"
	"				// hacky copied bit for page breaks\n"
	"				buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"				buffer.push([]);\n"
	"				curPageIndex++;\n"
	"				buffer[curPageIndex].push([]);\n"
	"				curRowIndex = 0;\n"
	"				curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);\n"
	"\n"
	"				afterManualPagebreak = false;\n"
	"			}\n"
	"			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {\n"
	"				//stay on same row\n"
	"				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects, activeTextEffectParameters);\n"
	"			}\n"
	"			else if (curRowIndex == 0) {\n"
	"				//start next row\n"
	"				buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"				buffer[curPageIndex].push([]);\n"
	"				curRowIndex++;\n"
	"				curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);\n"
	"			}\n"
	"			else {\n"
	"				//start next page\n"
	"				buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"				buffer.push([]);\n"
	"				curPageIndex++;\n"
	"				buffer[curPageIndex].push([]);\n"
	"				curRowIndex = 0;\n"
	"				curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		//destroy any empty stuff\n"
	"		var lastPage = buffer[buffer.length-1];\n"
	"		var lastRow = lastPage[lastPage.length-1];\n"
	"		if (lastRow.length == 0) {\n"
	"			lastPage.splice(lastPage.length-1, 1);\n"
	"		}\n"
	"		if (lastPage.length == 0) {\n"
	"			buffer.splice(buffer.length-1, 1);\n"
	"		}\n"
	"\n"
	"		//finish up \n"
	"		lastPage = buffer[buffer.length-1];\n"
	"		lastRow = lastPage[lastPage.length-1];\n"
	"		if (lastRow.length > 0) {\n"
	"			var lastChar = lastRow[lastRow.length-1];\n"
	"		}\n"
	"\n"
	"		// bitsy.log(buffer);\n"
	"\n"
	"		bitsy.log(\"add text finished\");\n"
	"\n"
	"		isActive = true;\n"
	"	};\n"
	"\n"
	"	this.AddLinebreak = function() {\n"
	"		var lastPage = buffer[buffer.length-1];\n"
	"		if (lastPage.length <= 1) {\n"
	"			// bitsy.log(\"LINEBREAK - NEW ROW \");\n"
	"			// add new row\n"
	"			lastPage.push([]);\n"
	"		}\n"
	"		else {\n"
	"			// add new page\n"
	"			buffer.push([[]]);\n"
	"		}\n"
	"		// bitsy.log(buffer);\n"
	"\n"
	"		isActive = true;\n"
	"	}\n"
	"\n"
	"	this.AddPagebreak = function(onReturnHandler) {\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		// need to actually create a whole new page if following another pagebreak character\n"
	"		if (afterManualPagebreak) {\n"
	"			this.FlipPage(); // hacky\n"
	"\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer.push([]);\n"
	"			curPageIndex++;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex = 0;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"			afterManualPagebreak = false;\n"
	"		}\n"
	"\n"
	"		var pagebreakChar = new DialogPageBreakChar();\n"
	"		pagebreakChar.SetContinueHandler(onReturnHandler);\n"
	"\n"
	"		curRowArr.push(pagebreakChar);\n"
	"\n"
	"		isActive = true;\n"
	"	}\n"
	"\n"
	"	this.hasTextEffect = function(name) {\n"
	"		return activeTextEffects.indexOf(name) != -1;\n"
	"	};\n"
	"\n"
	"	this.pushTextEffect = function(name, parameters) {\n"
	"		activeTextEffects.push(name);\n"
	"		activeTextEffectParameters.push(parameters);\n"
	"	};\n"
	"\n"
	"	this.popTextEffect = function(name) {\n"
	"		var i = activeTextEffects.lastIndexOf(name);\n"
	"		activeTextEffects.splice(i, 1);\n"
	"		activeTextEffectParameters.splice(i, 1);\n"
	"	};\n"
	"\n"
	"	/* this is a hook for GIF rendering */\n"
	"	var didPageFinishThisFrame = false;\n"
	"	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };\n"
	"\n"
	"	var didFlipPageThisFrame = false;\n"
	"	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };\n"
	"\n"
	"	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky\n"
	"};\n"
	"\n"
	"/* ARABIC */\n"
	"var ArabicHandler = function() {\n"
	"\n"
	"	var arabicCharStart = 0x0621;\n"
	"	var arabicCharEnd = 0x064E;\n"
	"\n"
	"	var CharacterForm = {\n"
	"		Isolated : 0,\n"
	"		Final : 1,\n"
	"		Initial : 2,\n"
	"		Middle : 3\n"
	"	};\n"
	"\n"
	"	// map glyphs to their character forms\n"
	"	var glyphForms = {\n"
	"		/*		 Isolated, Final, Initial, Middle Forms	*/\n"
	"		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ \n"
	"		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ \n"
	"		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ \n"
	"		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ \n"
	"		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ \n"
	"		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ \n"
	"		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ \n"
	"		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ \n"
	"		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ \n"
	"		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ \n"
	"		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ \n"
	"		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ \n"
	"		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ \n"
	"		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ \n"
	"		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ \n"
	"		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ \n"
	"		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ \n"
	"		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ \n"
	"		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ \n"
	"		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ \n"
	"		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ \n"
	"		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ \n"
	"		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ \n"
	"		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ \n"
	"		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ \n"
	"		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ \n"
	"		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ \n"
	"		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ \n"
	"		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ \n"
	"		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ \n"
	"		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ \n"
	"		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ \n"
	"		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ \n"
	"		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ \n"
	"		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ \n"
	"		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ \n"
	"		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ \n"
	"		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/\n"
	"		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/\n"
	"		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/\n"
	"		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */\n"
	"	};\n"
	"\n"
	"	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];\n"
	"\n"
	"	function IsArabicCharacter(char) {\n"
	"		var code = char.charCodeAt(0);\n"
	"		return (code >= arabicCharStart && code <= arabicCharEnd);\n"
	"	}\n"
	"\n"
	"	function ContainsArabicCharacters(word) {\n"
	"		for (var i = 0; i < word.length; i++) {\n"
	"			if (IsArabicCharacter(word[i])) {\n"
	"				return true;\n"
	"			}\n"
	"		}\n"
	"		return false;\n"
	"	}\n"
	"\n"
	"	function IsDisconnectedCharacter(char) {\n"
	"		var code = char.charCodeAt(0);\n"
	"		return disconnectedCharacters.indexOf(code) != -1;\n"
	"	}\n"
	"\n"
	"	function ShapeArabicCharacters(word) {\n"
	"		var shapedWord = \"\";\n"
	"\n"
	"		for (var i = 0; i < word.length; i++) {\n"
	"			if (!IsArabicCharacter(word[i])) {\n"
	"				shapedWord += word[i];\n"
	"				continue;\n"
	"			}\n"
	"\n"
	"			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);\n"
	"\n"
	"			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);\n"
	"\n"
	"			var form;\n"
	"			if (!connectedToPreviousChar && !connectedToNextChar) {\n"
	"				form = CharacterForm.Isolated;\n"
	"			}\n"
	"			else if (connectedToPreviousChar && !connectedToNextChar) {\n"
	"				form = CharacterForm.Final;\n"
	"			}\n"
	"			else if (!connectedToPreviousChar && connectedToNextChar) {\n"
	"				form = CharacterForm.Initial;\n"
	"			}\n"
	"			else if (connectedToPreviousChar && connectedToNextChar) {\n"
	"				form = CharacterForm.Middle;\n"
	"			}\n"
	"\n"
	"			var code = word[i].charCodeAt(0);\n"
	"\n"
	"			// handle lam alef special case\n"
	"			if (code == 0x0644 && connectedToNextChar) {\n"
	"				var nextCode = word[i+1].charCodeAt(0);\n"
	"				var specialCode = null;\n"
	"				if (nextCode == 0x0622) {\n"
	"					// alef madd\n"
	"					specialCode = glyphForms[0x064b][form];\n"
	"				}\n"
	"				else if (nextCode == 0x0623) {\n"
	"					// hamza above\n"
	"					specialCode = glyphForms[0x064c][form];\n"
	"				}\n"
	"				else if (nextCode == 0x0625) {\n"
	"					// hamza below\n"
	"					specialCode = glyphForms[0x064d][form];\n"
	"				}\n"
	"				else if (nextCode == 0x0627) {\n"
	"					// alef\n"
	"					specialCode = glyphForms[0x064e][form];\n"
	"				}\n"
	"\n"
	"				if (specialCode != null) {\n"
	"					shapedWord += String.fromCharCode(specialCode);\n"
	"					i++; // skip a step\n"
	"					continue;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			// hacky?\n"
	"			if (form === CharacterForm.Isolated) {\n"
	"				shapedWord += word[i];\n"
	"				continue;\n"
	"			}\n"
	"\n"
	"			var shapedCode = glyphForms[code][form];\n"
	"			shapedWord += String.fromCharCode(shapedCode);\n"
	"		}\n"
	"\n"
	"		return shapedWord;\n"
	"	}\n"
	"\n"
	"	this.ContainsArabicCharacters = ContainsArabicCharacters;\n"
	"	this.ShapeArabicCharacters = ShapeArabicCharacters;\n"
	"}\n"
	"\n"
	"/* TEXT EFFECTS */\n"
	"var TextEffects = {};\n"
	"\n"
	"function RainbowEffect() {\n"
	"	function positiveModulo(number, divisor) {\n"
	"		return ((number % divisor) + divisor) % divisor;\n"
	"	}\n"
	"\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		char.color = rainbowColorStartIndex + Math.floor(positiveModulo((time / 100) - char.col * 0.5, rainbowColorCount));\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"rbw\"] = new RainbowEffect();\n"
	"\n"
	"function ColorEffect(index) {\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		if (parameters && parameters.length > 0) {\n"
	"			char.color = tileColorStartIndex + parameters[0];\n"
	"		}\n"
	"		else {\n"
	"			char.color = tileColorStartIndex + index;\n"
	"		}\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"clr\"] = new ColorEffect();\n"
	"TextEffects[\"clr1\"] = new ColorEffect(0);\n"
	"TextEffects[\"clr2\"] = new ColorEffect(1);\n"
	"TextEffects[\"clr3\"] = new ColorEffect(2);\n"
	"\n"
	"function WavyEffect() {\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"wvy\"] = new WavyEffect();\n"
	"\n"
	"function ShakyEffect() {\n"
	"	function disturb(func, time, offset, mult1, mult2) {\n"
	"		return func((time * mult1) - (offset * mult2));\n"
	"	}\n"
	"\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		char.offset.y += 1.5\n"
	"						* disturb(Math.sin, time, char.col, 0.1, 0.5)\n"
	"						* disturb(Math.cos, time, char.col, 0.3, 0.2)\n"
	"						* disturb(Math.sin, time, char.row, 2.0, 1.0);\n"
	"		char.offset.x += 1.5\n"
	"						* disturb(Math.cos, time, char.row, 0.1, 1.0)\n"
	"						* disturb(Math.sin, time, char.col, 3.0, 0.7)\n"
	"						* disturb(Math.cos, time, char.col, 0.2, 0.3);\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"shk\"] = new ShakyEffect();\n"
	"\n"
	"/*\n"
	"// TODO : maybe use this in a future update?\n"
	"function YakEffect() {\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		if (char.char != \" \") {\n"
	"			char.blip = parameters[0];\n"
	"		}\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"yak\"] = new YakEffect();\n"
	"*/\n"
	"\n"
	"var DebugHighlightEffect = function() {\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		char.color = tileColorStartIndex;\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"_debug_highlight\"] = new DebugHighlightEffect();\n"
	"\n"
	"} // Dialog()\n";

char* transition_js =
	"var TransitionManager = function() {\n"
	"	var transitionStart = null;\n"
	"	var transitionEnd = null;\n"
	"\n"
	"	var isTransitioning = false;\n"
	"	var transitionTime = 0; // milliseconds\n"
	"	var minStepTime = 125; // cap the frame rate\n"
	"	var curStep = 0;\n"
	"\n"
	"	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectName) {\n"
	"		bitsy.log(\"--- START ROOM TRANSITION ---\");\n"
	"\n"
	"		curEffect = effectName;\n"
	"\n"
	"		var tmpRoom = player().room;\n"
	"		var tmpX = player().x;\n"
	"		var tmpY = player().y;\n"
	"\n"
	"		if (transitionEffects[curEffect].showPlayerStart) {\n"
	"			player().room = startRoom;\n"
	"			player().x = startX;\n"
	"			player().y = startY;\n"
	"		}\n"
	"		else {\n"
	"			player().room = \"_transition_none\"; // kind of hacky!!\n"
	"		}\n"
	"\n"
	"		var startRoomPixels = createRoomPixelBuffer(room[startRoom]);\n"
	"		var startPalette = getPal(room[startRoom].pal);\n"
	"		var startImage = new PostProcessImage(startRoomPixels);\n"
	"		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);\n"
	"\n"
	"		if (transitionEffects[curEffect].showPlayerEnd) {\n"
	"			player().room = endRoom;\n"
	"			player().x = endX;\n"
	"			player().y = endY;\n"
	"		}\n"
	"		else {\n"
	"			player().room = \"_transition_none\";\n"
	"		}\n"
	"\n"
	"		var endRoomPixels = createRoomPixelBuffer(room[endRoom]);\n"
	"		var endPalette = getPal(room[endRoom].pal);\n"
	"		var endImage = new PostProcessImage(endRoomPixels);\n"
	"		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);\n"
	"\n"
	"		isTransitioning = true;\n"
	"		transitionTime = 0;\n"
	"		curStep = 0;\n"
	"\n"
	"		player().room = endRoom;\n"
	"		player().x = endX;\n"
	"		player().y = endY;\n"
	"\n"
	"		bitsy.graphicsMode(bitsy.GFX_VIDEO);\n"
	"	}\n"
	"\n"
	"	this.UpdateTransition = function(dt) {\n"
	"		if (!isTransitioning) {\n"
	"			return;\n"
	"		}\n"
	"\n"
	"		transitionTime += dt;\n"
	"\n"
	"		var maxStep = transitionEffects[curEffect].stepCount;\n"
	"\n"
	"		if (transitionTime >= minStepTime) {\n"
	"			curStep++;\n"
	"\n"
	"			var step = curStep;\n"
	"			bitsy.log(\"transition step \" + step);\n"
	"\n"
	"			if (transitionEffects[curEffect].paletteEffectFunc) {\n"
	"				var colors = transitionEffects[curEffect].paletteEffectFunc(transitionStart, transitionEnd, (step / maxStep));\n"
	"				updatePaletteWithTileColors(colors);\n"
	"			}\n"
	"\n"
	"			bitsy.fill(bitsy.VIDEO, tileColorStartIndex);\n"
	"\n"
	"			for (var y = 0; y < bitsy.VIDEO_SIZE; y++) {\n"
	"				for (var x = 0; x < bitsy.VIDEO_SIZE; x++) {\n"
	"					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart, transitionEnd, x, y, (step / maxStep));\n"
	"					bitsy.set(bitsy.VIDEO, (y * bitsy.VIDEO_SIZE) + x, color);\n"
	"				}\n"
	"			}\n"
	"\n"
	"			transitionTime = 0;\n"
	"		}\n"
	"\n"
	"		if (curStep >= (maxStep - 1)) {\n"
	"			isTransitioning = false;\n"
	"			transitionTime = 0;\n"
	"			transitionStart = null;\n"
	"			transitionEnd = null;\n"
	"			curStep = 0;\n"
	"\n"
	"			if (transitionCompleteCallback != null) {\n"
	"				transitionCompleteCallback();\n"
	"			}\n"
	"			transitionCompleteCallback = null;\n"
	"\n"
	"			bitsy.graphicsMode(bitsy.GFX_MAP);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.IsTransitionActive = function() {\n"
	"		return isTransitioning;\n"
	"	}\n"
	"\n"
	"	// todo : should this be part of the constructor?\n"
	"	var transitionCompleteCallback = null;\n"
	"	this.OnTransitionComplete = function(callback) {\n"
	"		if (isTransitioning) { // TODO : safety check necessary?\n"
	"			transitionCompleteCallback = callback;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	var transitionEffects = {};\n"
	"	var curEffect = \"none\";\n"
	"	this.RegisterTransitionEffect = function(name, effect) {\n"
	"		transitionEffects[name] = effect;\n"
	"	}\n"
	"\n"
	"	this.RegisterTransitionEffect(\"none\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : false,\n"
	"		paletteEffectFunc : function() {},\n"
	"		pixelEffectFunc : function() {},\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"fade_w\", { // TODO : have it linger on full white briefly?\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 6,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);\n"
	"		},\n"
	"		paletteEffectFunc : function(start, end, delta) {\n"
	"			var colors = [];\n"
	"\n"
	"			if (delta < 0.5) {\n"
	"				delta = delta / 0.5;\n"
	"\n"
	"				for (var i = 0; i < start.Palette.length; i++) {\n"
	"					colors.push(lerpColor(start.Palette[i], [255, 255, 255], delta));\n"
	"				}\n"
	"			}\n"
	"			else {\n"
	"				delta = ((delta - 0.5) / 0.5);\n"
	"\n"
	"				for (var i = 0; i < end.Palette.length; i++) {\n"
	"					colors.push(lerpColor([255, 255, 255], end.Palette[i], delta));\n"
	"				}\n"
	"			}\n"
	"\n"
	"			return colors;\n"
	"		},\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"fade_b\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 6,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);\n"
	"		},\n"
	"		paletteEffectFunc : function(start, end, delta) {\n"
	"			var colors = [];\n"
	"\n"
	"			if (delta < 0.5) {\n"
	"				delta = delta / 0.5;\n"
	"\n"
	"				for (var i = 0; i < start.Palette.length; i++) {\n"
	"					colors.push(lerpColor(start.Palette[i], [0, 0, 0], delta));\n"
	"				}\n"
	"			}\n"
	"			else {\n"
	"				delta = ((delta - 0.5) / 0.5);\n"
	"\n"
	"				for (var i = 0; i < end.Palette.length; i++) {\n"
	"					colors.push(lerpColor([0, 0, 0], end.Palette[i], delta));\n"
	"				}\n"
	"			}\n"
	"\n"
	"			return colors;\n"
	"		},\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"wave\", {\n"
	"		showPlayerStart : true,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 12,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);\n"
	"\n"
	"			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));\n"
	"			var freq = 4;\n"
	"			var size = 2 + (14 * waveDelta);\n"
	"			pixelX += Math.floor(Math.sin(offset / freq) * size);\n"
	"\n"
	"			if (pixelX < 0) {\n"
	"				pixelX += start.Image.Width;\n"
	"			}\n"
	"			else if (pixelX >= start.Image.Width) {\n"
	"				pixelX -= start.Image.Width;\n"
	"			}\n"
	"\n"
	"			var curImage = delta < 0.5 ? start.Image : end.Image;\n"
	"			return curImage.GetPixel(pixelX, pixelY);\n"
	"		},\n"
	"		paletteEffectFunc : function(start, end, delta) {\n"
	"			return delta < 0.5 ? start.Palette : end.Palette;\n"
	"		},\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"tunnel\", {\n"
	"		showPlayerStart : true,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 12,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			if (delta <= 0.4) {\n"
	"				var tunnelDelta = 1 - (delta / 0.4);\n"
	"\n"
	"				var xDist = start.PlayerCenter.x - pixelX;\n"
	"				var yDist = start.PlayerCenter.y - pixelY;\n"
	"				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));\n"
	"\n"
	"				if (dist > start.Image.Width * tunnelDelta) {\n"
	"					return 0;\n"
	"				}\n"
	"				else {\n"
	"					return start.Image.GetPixel(pixelX, pixelY);\n"
	"				}\n"
	"			}\n"
	"			else if (delta <= 0.6) {\n"
	"				return 0;\n"
	"			}\n"
	"			else {\n"
	"				var tunnelDelta = (delta - 0.6) / 0.4;\n"
	"\n"
	"				var xDist = end.PlayerCenter.x - pixelX;\n"
	"				var yDist = end.PlayerCenter.y - pixelY;\n"
	"				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));\n"
	"\n"
	"				if (dist > end.Image.Width * tunnelDelta) {\n"
	"					return 0;\n"
	"				}\n"
	"				else {\n"
	"					return end.Image.GetPixel(pixelX, pixelY);\n"
	"				}\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : function(start, end, delta) {\n"
	"			return delta < 0.5 ? start.Palette : end.Palette;\n"
	"		},\n"
	"	});\n"
	"\n"
	"	function lerpPalettes(start, end, delta) {\n"
	"		var colors = [];\n"
	"\n"
	"		var maxLength = (start.Palette.length > end.Palette.length) ?\n"
	"			start.Palette.length : end.Palette.length;\n"
	"\n"
	"		for (var i = 0; i < maxLength; i++) {\n"
	"			if (i < start.Palette.length && i < end.Palette.length) {\n"
	"				colors.push(lerpColor(start.Palette[i], end.Palette[i], delta));\n"
	"			}\n"
	"			else if (i < start.Palette.length) {\n"
	"				colors.push(lerpColor(\n"
	"					start.Palette[i],\n"
	"					end.Palette[end.Palette.length - 1],\n"
	"					delta));\n"
	"			}\n"
	"			else if (i < end.Palette.length) {\n"
	"				colors.push(lerpColor(\n"
	"					start.Palette[start.Palette.length - 1],\n"
	"					end.Palette[i],\n"
	"					delta));\n"
	"			}\n"
	"		}\n"
	"\n"
	"		return colors;\n"
	"	}\n"
	"\n"
	"	this.RegisterTransitionEffect(\"slide_u\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 8,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);\n"
	"			var slidePixelY = pixelY + pixelOffset;\n"
	"\n"
	"			if (slidePixelY >= 0) {\n"
	"				return start.Image.GetPixel(pixelX, slidePixelY);\n"
	"			}\n"
	"			else {\n"
	"				slidePixelY += start.Image.Height;\n"
	"				return end.Image.GetPixel(pixelX, slidePixelY);\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : lerpPalettes,\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"slide_d\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 8,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var pixelOffset = Math.floor(start.Image.Height * delta);\n"
	"			var slidePixelY = pixelY + pixelOffset;\n"
	"\n"
	"			if (slidePixelY < start.Image.Height) {\n"
	"				return start.Image.GetPixel(pixelX, slidePixelY);\n"
	"			}\n"
	"			else {\n"
	"				slidePixelY -= start.Image.Height;\n"
	"				return end.Image.GetPixel(pixelX, slidePixelY);\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : lerpPalettes,\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"slide_l\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 8,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);\n"
	"			var slidePixelX = pixelX + pixelOffset;\n"
	"\n"
	"			if (slidePixelX >= 0) {\n"
	"				return start.Image.GetPixel(slidePixelX, pixelY);\n"
	"			}\n"
	"			else {\n"
	"				slidePixelX += start.Image.Width;\n"
	"				return end.Image.GetPixel(slidePixelX, pixelY);\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : lerpPalettes,\n"
	"	});\n"
	"\n"
	"	this.RegisterTransitionEffect(\"slide_r\", {\n"
	"		showPlayerStart : false,\n"
	"		showPlayerEnd : true,\n"
	"		stepCount : 8,\n"
	"		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {\n"
	"			var pixelOffset = Math.floor(start.Image.Width * delta);\n"
	"			var slidePixelX = pixelX + pixelOffset;\n"
	"\n"
	"			if (slidePixelX < start.Image.Width) {\n"
	"				return start.Image.GetPixel(slidePixelX, pixelY);\n"
	"			}\n"
	"			else {\n"
	"				slidePixelX -= start.Image.Width;\n"
	"				return end.Image.GetPixel(slidePixelX, pixelY);\n"
	"			}\n"
	"		},\n"
	"		paletteEffectFunc : lerpPalettes,\n"
	"	});\n"
	"\n"
	"	// todo : move to Renderer()?\n"
	"	function createRoomPixelBuffer(room) {\n"
	"		var pixelBuffer = [];\n"
	"\n"
	"		for (var i = 0; i < bitsy.VIDEO_SIZE * bitsy.VIDEO_SIZE; i++) {\n"
	"			pixelBuffer.push(tileColorStartIndex);\n"
	"		}\n"
	"\n"
	"		var drawTileInPixelBuffer = function(sourceData, frameIndex, colorIndex, tx, ty, pixelBuffer) {\n"
	"			var frameData = sourceData[frameIndex];\n"
	"\n"
	"			for (var y = 0; y < bitsy.TILE_SIZE; y++) {\n"
	"				for (var x = 0; x < bitsy.TILE_SIZE; x++) {\n"
	"					var color = tileColorStartIndex + (frameData[y][x] === 1 ? colorIndex : 0);\n"
	"					pixelBuffer[(((ty * bitsy.TILE_SIZE) + y) * bitsy.VIDEO_SIZE) + ((tx * bitsy.TILE_SIZE) + x)] = color;\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"\n"
	"		//draw tiles\n"
	"		for (i in room.tilemap) {\n"
	"			for (j in room.tilemap[i]) {\n"
	"				var id = room.tilemap[i][j];\n"
	"				var x = parseInt(j);\n"
	"				var y = parseInt(i);\n"
	"\n"
	"				if (id != \"0\" && tile[id] != null) {\n"
	"					drawTileInPixelBuffer(\n"
	"						renderer.GetDrawingSource(tile[id].drw),\n"
	"						tile[id].animation.frameIndex,\n"
	"						tile[id].col,\n"
	"						x,\n"
	"						y,\n"
	"						pixelBuffer);\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"\n"
	"		//draw items\n"
	"		for (var i = 0; i < room.items.length; i++) {\n"
	"			var itm = room.items[i];\n"
	"			drawTileInPixelBuffer(\n"
	"				renderer.GetDrawingSource(item[itm.id].drw),\n"
	"				item[itm.id].animation.frameIndex,\n"
	"				item[itm.id].col,\n"
	"				itm.x,\n"
	"				itm.y,\n"
	"				pixelBuffer);\n"
	"		}\n"
	"\n"
	"		//draw sprites\n"
	"		for (id in sprite) {\n"
	"			var spr = sprite[id];\n"
	"			if (spr.room === room.id) {\n"
	"				drawTileInPixelBuffer(\n"
	"					renderer.GetDrawingSource(spr.drw),\n"
	"					spr.animation.frameIndex,\n"
	"					spr.col,\n"
	"					spr.x,\n"
	"					spr.y,\n"
	"					pixelBuffer);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		return pixelBuffer;\n"
	"	}\n"
	"\n"
	"	function lerpColor(colorA, colorB, t) {\n"
	"		return [\n"
	"			colorA[0] + ((colorB[0] - colorA[0]) * t),\n"
	"			colorA[1] + ((colorB[1] - colorA[1]) * t),\n"
	"			colorA[2] + ((colorB[2] - colorA[2]) * t),\n"
	"		];\n"
	"	};\n"
	"}; // TransitionManager()\n"
	"\n"
	"// todo : is this wrapper still useful?\n"
	"var PostProcessImage = function(imageData) {\n"
	"	this.Width = bitsy.VIDEO_SIZE;\n"
	"	this.Height = bitsy.VIDEO_SIZE;\n"
	"\n"
	"	this.GetPixel = function(x, y) {\n"
	"		return imageData[(y * bitsy.VIDEO_SIZE) + x];\n"
	"	};\n"
	"\n"
	"	this.GetData = function() {\n"
	"		return imageData;\n"
	"	};\n"
	"};\n"
	"\n"
	"var TransitionInfo = function(image, palette, playerX, playerY) {\n"
	"	this.Image = image;\n"
	"\n"
	"	this.Palette = palette;\n"
	"\n"
	"	this.PlayerTilePos = {\n"
	"		x: playerX,\n"
	"		y: playerY\n"
	"	};\n"
	"\n"
	"	this.PlayerCenter = {\n"
	"		x: Math.floor((playerX * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2)),\n"
	"		y: Math.floor((playerY * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2))\n"
	"	};\n"
	"};\n";

char* sound_js =
	"/* PITCH HELPER FUNCTIONS */\n"
	"function pitchToSteps(pitch) {\n"
	"	return (pitch.octave * Note.COUNT) + pitch.note;\n"
	"}\n"
	"\n"
	"function stepsToPitch(steps) {\n"
	"	var pitch = { beats: 1, note: Note.C, octave: Octave[2], };\n"
	"\n"
	"	while (steps >= Note.COUNT) {\n"
	"		pitch.octave = (pitch.octave + 1) % Octave.COUNT;\n"
	"		steps -= Note.COUNT;\n"
	"	}\n"
	"\n"
	"	pitch.note += steps;\n"
	"\n"
	"	// make sure pitch isn't outside a valid range\n"
	"	if (pitch.note <= Note.NONE) {\n"
	"		pitch.note = Note.C;\n"
	"	}\n"
	"	else if (pitch.note >= Note.COUNT) {\n"
	"		pitch.note = Note.B;\n"
	"	}\n"
	"\n"
	"	if (pitch.octave <= Octave.NONE) {\n"
	"		pitch.octave = Octave[2];\n"
	"	}\n"
	"	else if (pitch.octave >= Octave.COUNT) {\n"
	"		pitch.octave = Octave[5];\n"
	"	}\n"
	"\n"
	"	return pitch;\n"
	"}\n"
	"\n"
	"function adjustPitch(pitch, stepDelta) {\n"
	"	return stepsToPitch(pitchToSteps(pitch) + stepDelta);\n"
	"}\n"
	"\n"
	"function pitchDistance(pitchA, pitchB) {\n"
	"	return pitchToSteps(pitchB) - pitchToSteps(pitchA);\n"
	"}\n"
	"\n"
	"function isMinPitch(pitch) {\n"
	"	return pitchToSteps(pitch) <= pitchToSteps({ note: Note.C, octave: Octave[2] });\n"
	"}\n"
	"\n"
	"function isMaxPitch(pitch) {\n"
	"	return pitchToSteps(pitch) >= pitchToSteps({ note: Note.B, octave: Octave[5] });\n"
	"}\n"
	"\n"
	"function SoundPlayer() {\n"
	"	// frequencies (in hertz) for octave 0 (or is it octave 4?)\n"
	"	var frequencies = [\n"
	"		261.7, // middle C\n"
	"		277.2,\n"
	"		293.7,\n"
	"		311.2,\n"
	"		329.7,\n"
	"		349.3,\n"
	"		370.0,\n"
	"		392.0,\n"
	"		415.3,\n"
	"		440.0,\n"
	"		466.2,\n"
	"		493.9,\n"
	"	];\n"
	"\n"
	"	// tempos are calculated as the duration of a 16th note, rounded to the nearest millisecond\n"
	"	var tempos = {};\n"
	"	tempos[Tempo.SLW] = 250; // 60bpm (adagio)\n"
	"	tempos[Tempo.MED] = 188; // ~80bpm (andante) [exact would be 187.5 ms]\n"
	"	tempos[Tempo.FST] = 125; // 120bpm (moderato)\n"
	"	tempos[Tempo.XFST] = 94; // ~160bpm (allegro) [exact would be 93.75 ms]\n"
	"\n"
	"	// arpeggio patterns expressed in scale degrees\n"
	"	var arpeggioPattern = {};\n"
	"	arpeggioPattern[ArpeggioPattern.UP] = [0, 2, 4, 7];\n"
	"	arpeggioPattern[ArpeggioPattern.DWN] = [7, 4, 2, 0];\n"
	"	arpeggioPattern[ArpeggioPattern.INT5] = [0, 4];\n"
	"	arpeggioPattern[ArpeggioPattern.INT8] = [0, 7];\n"
	"\n"
	"	this.getArpeggioSteps = function(tune) { return arpeggioPattern[tune.arpeggioPattern]; };\n"
	"\n"
	"	function isPitchPlayable(pitch, key) {\n"
	"		if (pitch.beats <= 0) {\n"
	"			return false;\n"
	"		}\n"
	"\n"
	"		if (key === undefined || key === null) {\n"
	"			return true;\n"
	"		}\n"
	"\n"
	"		// test if note is in the scale\n"
	"		return (key.scale.indexOf(pitch.note) > -1)\n"
	"			&& (key.notes[pitch.note] > Note.NONE)\n"
	"			&& (key.notes[pitch.note] < Note.COUNT);\n"
	"	}\n"
	"\n"
	"	function pitchToChromatic(pitch, key) {\n"
	"		if (pitch === undefined || pitch === null) {\n"
	"			return null;\n"
	"		}\n"
	"\n"
	"		if (key === undefined || key === null) {\n"
	"			return pitch;\n"
	"		}\n"
	"\n"
	"		// convert from solfa\n"
	"		var octaveOffset = (pitch.note >= Solfa.COUNT) ? 1 : 0;\n"
	"\n"
	"		return {\n"
	"			beats: pitch.beats,\n"
	"			octave: pitch.octave + octaveOffset,\n"
	"			// todo : what about the scale limits?\n"
	"			note: key.notes[(pitch.note % Solfa.COUNT)],\n"
	"			blip: pitch.blip\n"
	"		};\n"
	"	}\n"
	"\n"
	"	function makePitchFrequency(pitch) {\n"
	"		// todo : this clamp shouldn't be required.. there's a bug in the pitch shifting somewhere\n"
	"		var note = Math.max(0, pitch.note);\n"
	"		var octave = (pitch.octave != undefined ? pitch.octave : Octave[4]);\n"
	"\n"
	"		var octaveMin = Octave[2];\n"
	"		var octaveMax = Octave[5];\n"
	"\n"
	"		// make sure octave is in valid range\n"
	"		octave = Math.max(octaveMin, Math.min(octave, octaveMax));\n"
	"		var distFromMiddleC = octave - 2;\n"
	"\n"
	"		var freq = frequencies[note] * Math.pow(2, distFromMiddleC);\n"
	"\n"
	"		if (isNaN(freq)) {\n"
	"			bitsy.log(\"invalid frequency \" + pitch, \"sound\");\n"
	"		}\n"
	"\n"
	"		return freq;\n"
	"	}\n"
	"\n"
	"	var maxVolume = 15; // todo : should this be a system constant?\n"
	"	var noteVolume = 5;\n"
	"\n"
	"	var curTune = null;\n"
	"	var isTunePaused = false;\n"
	"	var barIndex = -1;\n"
	"	var curArpeggio = [];\n"
	"\n"
	"	var beat16 = 0;\n"
	"	var beat16Timer = 0;\n"
	"	var beat16Index = 0;\n"
	"\n"
	"	// special settings\n"
	"	var isLooping = false;\n"
	"	var isMelodyMuted = false;\n"
	"	var maxBeatCount = null;\n"
	"	var muteTimer = 0; // allow temporary muting of all notes\n"
	"\n"
	"	function arpeggiateBar(bar, key, pattern) {\n"
	"		var arpeggio = [];\n"
	"\n"
	"		if (key != undefined && key != null && isPitchPlayable(bar[0], key)) {\n"
	"			for (var i = 0; i < arpeggioPattern[pattern].length; i++) {\n"
	"				var pitch = { beats: 1, note: bar[0].note + arpeggioPattern[pattern][i], octave: bar[0].octave };\n"
	"				arpeggio.push(pitchToChromatic(pitch, key));\n"
	"			}\n"
	"		}\n"
	"\n"
	"		for (var i = 0; i < arpeggio.length; i++) {\n"
	"			bitsy.log(i + \": \" + serializeNote(arpeggio[i].note));\n"
	"		}\n"
	"\n"
	"		return arpeggio;\n"
	"	};\n"
	"\n"
	"	function playNote(pitch, instrument, options) {\n"
	"		if (pitch.beats <= 0) {\n"
	"			return;\n"
	"		}\n"
	"\n"
	"		var channel = bitsy.SOUND1;\n"
	"		if (options != undefined && options.channel != undefined) {\n"
	"			channel = options.channel;\n"
	"		}\n"
	"\n"
	"		var key = null;\n"
	"		if (options != undefined && options.key != undefined) {\n"
	"			key = options.key;\n"
	"		}\n"
	"\n"
	"		var beatLen = beat16;\n"
	"		if (options != undefined && options.beatLen != undefined) {\n"
	"			beatLen = options.beatLen;\n"
	"		}\n"
	"\n"
	"		if (isPitchPlayable(pitch, key)) {\n"
	"			var freq = makePitchFrequency(pitchToChromatic(pitch, key));\n"
	"			bitsy.sound(channel, (pitch.beats * beatLen), freq * 100, noteVolume, instrument);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	function sfxFrequencyAtTime(sfx, time) {\n"
	"		var beatDelay = sfx.blip.beat.delay;\n"
	"		var beatTime = sfx.blip.beat.time;\n"
	"		var delta = Math.max(0, time - beatDelay) / beatTime;\n"
	"\n"
	"		var pitchDelta = sfx.blip.doRepeat\n"
	"			? (delta % sfx.frequencies.length)\n"
	"			: Math.min(delta, sfx.frequencies.length - 1);\n"
	"\n"
	"		sfx.pitchIndex = Math.floor(pitchDelta);\n"
	"		var curFreq = sfx.frequencies[sfx.pitchIndex];\n"
	"\n"
	"		// TODO : consider for future update\n"
	"		// if (sfx.blip.doSlide) {\n"
	"		// 	var nextPitchIndex = (sfx.pitchIndex + 1) % sfx.frequencies.length;\n"
	"		// 	var nextFreq = sfx.frequencies[nextPitchIndex];\n"
	"		// 	var d = pitchDelta - sfx.pitchIndex;\n"
	"		// 	curFreq = curFreq + ((nextFreq - curFreq) * d);\n"
	"		// }\n"
	"\n"
	"		return curFreq;\n"
	"	}\n"
	"\n"
	"	function sfxVolumeAtTime(sfx, time) {\n"
	"		var volume = 0;\n"
	"\n"
	"		// use envelope settings to calculate volume\n"
	"		var attack = sfx.blip.envelope.attack;\n"
	"		var decay = sfx.blip.envelope.decay;\n"
	"		var length = sfx.blip.envelope.length;\n"
	"		var release = sfx.blip.envelope.release;\n"
	"		if (time < attack) {\n"
	"			// attack\n"
	"			var t = time / attack;\n"
	"			volume = Math.floor(sfxPeakVolume * t);\n"
	"		}\n"
	"		else if (time < attack + decay) {\n"
	"			// decay\n"
	"			var t = (time - attack) / decay;\n"
	"			var d = sfx.blip.envelope.sustain - sfxPeakVolume;\n"
	"			volume = Math.floor(sfxPeakVolume + (d * t));\n"
	"		}\n"
	"		else if (time < attack + decay + length) {\n"
	"			// sustain\n"
	"			volume = sfx.blip.envelope.sustain;\n"
	"		}\n"
	"		else if (time < attack + decay + length + release) {\n"
	"			// release\n"
	"			var t = (time - (attack + decay + length)) / release;\n"
	"			volume = Math.floor(sfx.blip.envelope.sustain * (1 - t));\n"
	"		}\n"
	"		else {\n"
	"			volume = 0;\n"
	"		}\n"
	"\n"
	"		return volume;\n"
	"	}\n"
	"\n"
	"	function updateSfx(dt) {\n"
	"		// try limiting the max change per frame\n"
	"		dt = Math.min(dt, 32);\n"
	"		var isAnyBlipPlaying = false;\n"
	"\n"
	"		if (activeSfx != null) {\n"
	"			isAnyBlipPlaying = true;\n"
	"			var sfx = activeSfx;\n"
	"\n"
	"			sfx.timer += dt;\n"
	"			if (sfx.timer >= sfx.duration) {\n"
	"				sfx.timer = sfx.duration;\n"
	"			}\n"
	"\n"
	"			if (sfx.frequencies.length > 0) {\n"
	"				// update pitch\n"
	"				var prevPitchIndex = sfx.pitchIndex;\n"
	"				var freq = sfxFrequencyAtTime(sfx, sfx.timer);\n"
	"				if (prevPitchIndex != sfx.pitchIndex) {\n"
	"					// pitch changed!\n"
	"					bitsy.frequency(bitsy.SOUND1, freq * 100);\n"
	"				}\n"
	"\n"
	"				// update volume envelope\n"
	"				bitsy.volume(bitsy.SOUND1, sfxVolumeAtTime(sfx, sfx.timer));\n"
	"			}\n"
	"\n"
	"			if (sfx.timer >= sfx.duration) {\n"
	"				// turn off sound\n"
	"				bitsy.volume(bitsy.SOUND1, 0);\n"
	"				activeSfx = null;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		if (isMusicPausedForBlip && !isAnyBlipPlaying) {\n"
	"			isMusicPausedForBlip = false;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	function updateTune(dt) {\n"
	"		if (curTune === undefined || curTune === null) {\n"
	"			return;\n"
	"		}\n"
	"\n"
	"		beat16Timer += dt;\n"
	"\n"
	"		if (muteTimer > 0) {\n"
	"			muteTimer -= dt;\n"
	"		}\n"
	"\n"
	"		if (beat16Timer >= beat16) {\n"
	"			beat16Timer = 0;\n"
	"			beat16Index++;\n"
	"\n"
	"			if (beat16Index >= 16) {\n"
	"				beat16Index = 0;\n"
	"\n"
	"				if (!isLooping) {\n"
	"					barIndex = (barIndex + 1) % curTune.melody.length;\n"
	"\n"
	"					if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {\n"
	"						curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (muteTimer <= 0) {\n"
	"				if (!isMelodyMuted) {\n"
	"					// melody note\n"
	"					var pitchA = curTune.melody[barIndex][beat16Index];\n"
	"					if (pitchA.beats > 0) {\n"
	"						// since they're played on the same channel, any melody note will cancel a blip\n"
	"						activeSfx = null;\n"
	"					}\n"
	"\n"
	"					if (pitchA.blip != undefined && pitchA.beats > 0) {\n"
	"						playBlip(blip[pitchA.blip], { interruptMusic: false, pitch: pitchA, key: curTune.key });\n"
	"					}\n"
	"					else {\n"
	"						playNote(pitchA, curTune.instrumentA, { channel: bitsy.SOUND1, key: curTune.key });\n"
	"					}\n"
	"				}\n"
	"\n"
	"				if (curTune.arpeggioPattern === ArpeggioPattern.OFF) {\n"
	"					// harmony note\n"
	"					var pitchB = curTune.harmony[barIndex][beat16Index];\n"
	"					if (pitchB.blip != undefined && pitchB.beats > 0) {\n"
	"						playBlip(blip[pitchB.blip], { interruptMusic: false, pitch: pitchB, key: curTune.key });\n"
	"					}\n"
	"					else {\n"
	"						playNote(pitchB, curTune.instrumentB, { channel: bitsy.SOUND2, key: curTune.key });\n"
	"					}\n"
	"				}\n"
	"				else {\n"
	"					var arpPitch = curArpeggio[beat16Index % curArpeggio.length];\n"
	"					if (arpPitch != undefined && arpPitch.beats > 0) {\n"
	"						playNote(arpPitch, curTune.instrumentB, { channel: bitsy.SOUND2, beatLen: beat16 });\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (maxBeatCount != null && beat16Index >= (maxBeatCount - 1)) {\n"
	"				// stop playback early\n"
	"				curTune = null;\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.update = function(dt) {\n"
	"		updateSfx(dt);\n"
	"		if (!isTunePaused && !isMusicPausedForBlip) {\n"
	"			updateTune(dt);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.playTune = function(tune, options) {\n"
	"		curTune = tune;\n"
	"		beat16Timer = 0;\n"
	"		beat16Index = -1;\n"
	"		barIndex = 0;\n"
	"\n"
	"		isLooping = false;\n"
	"		isMelodyMuted = false;\n"
	"		maxBeatCount = null;\n"
	"\n"
	"		// special options for the editor\n"
	"		if (options != undefined) {\n"
	"			if (options.barIndex != undefined) {\n"
	"				barIndex = options.barIndex;\n"
	"			}\n"
	"\n"
	"			if (options.loop != undefined) {\n"
	"				isLooping = options.loop;\n"
	"			}\n"
	"\n"
	"			if (options.melody != undefined) {\n"
	"				isMelodyMuted = !options.melody;\n"
	"			}\n"
	"\n"
	"			if (options.beatCount != undefined) {\n"
	"				maxBeatCount = options.beatCount;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// update tempo\n"
	"		beat16 = tempos[curTune.tempo];\n"
	"\n"
	"		if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {\n"
	"			curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.isTunePlaying = function() {\n"
	"		return curTune != null;\n"
	"	};\n"
	"\n"
	"	this.getCurTuneId = function() {\n"
	"		if (curTune) {\n"
	"			return curTune.id;\n"
	"		}\n"
	"\n"
	"		return null;\n"
	"	};\n"
	"\n"
	"	this.stopTune = function() {\n"
	"		curTune = null;\n"
	"	};\n"
	"\n"
	"	this.pauseTune = function() {\n"
	"		isTunePaused = true;\n"
	"	};\n"
	"\n"
	"	this.resumeTune = function() {\n"
	"		isTunePaused = false;\n"
	"	};\n"
	"\n"
	"	this.getBeat = function() {\n"
	"		if (curTune == null) {\n"
	"			return null;\n"
	"		}\n"
	"\n"
	"		return {\n"
	"			bar : barIndex,\n"
	"			beat : beat16Index,\n"
	"		};\n"
	"	};\n"
	"\n"
	"	this.getBlipState = function() {\n"
	"		return activeSfx;\n"
	"	};\n"
	"\n"
	"	this.playNote = function(pitch, instrument, channel, key) {\n"
	"		beat16 = tempos[Tempo.SLW];\n"
	"		muteTimer = beat16;\n"
	"		playNote(pitch, instrument, { channel: channel, key: key });\n"
	"	};\n"
	"\n"
	"	this.setTempo = function(tempo) {\n"
	"		beat16 = tempos[tempo];\n"
	"	};\n"
	"\n"
	"	this.setLooping = function(looping) {\n"
	"		isLooping = looping;\n"
	"	};\n"
	"\n"
	"	/* SOUND EFFECTS */\n"
	"	var sfxPeakVolume = 10; // todo : is this a good value?\n"
	"	var activeSfx = null;\n"
	"	var isMusicPausedForBlip = false;\n"
	"\n"
	"	function createSfxState(blip, pitch, isPitchRandomized) {\n"
	"		// bitsy.log(\"init sfx blip: \" + blip.id);\n"
	"\n"
	"		var sfxState = {\n"
	"			blip : blip,\n"
	"			pitchIndex : -1,\n"
	"			frequencies : [],\n"
	"			timer : 0,\n"
	"			duration : 0,\n"
	"		};\n"
	"\n"
	"		// is it weird to track this both in the system *AND* the engine?\n"
	"		sfxState.duration = (blip.envelope.attack + blip.envelope.decay + blip.envelope.length + blip.envelope.release);\n"
	"\n"
	"		// adjust starting pitch\n"
	"		var step = 0;\n"
	"		if (pitch != null) {\n"
	"			step = pitchDistance(blip.pitchA, pitch);\n"
	"		}\n"
	"		else if (isPitchRandomized > 0) {\n"
	"			step = Math.floor(Math.random() * 6);\n"
	"		}\n"
	"\n"
	"		if (blip.pitchA.beats > 0) {\n"
	"			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchA, step)));\n"
	"		}\n"
	"		if (blip.pitchB.beats > 0) {\n"
	"			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchB, step)));\n"
	"		}\n"
	"		if (blip.pitchC.beats > 0) {\n"
	"			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchC, step)));\n"
	"		}\n"
	"\n"
	"		return sfxState;\n"
	"	}\n"
	"\n"
	"	function playBlip(blip, options) {\n"
	"		// default to pausing music while the blip plays (except when playing a blip as *part* of music)\n"
	"		isMusicPausedForBlip = (options === undefined || options.interruptMusic === undefined) ? true : options.interruptMusic;\n"
	"\n"
	"		// always play blips on channel 1\n"
	"		var channel = bitsy.SOUND1;\n"
	"\n"
	"		// other options\n"
	"		var pitch = (options === undefined || options.pitch === undefined) ? null : options.pitch;\n"
	"		var isPitchRandomized = (options === undefined || options.isPitchRandomized === undefined) ? false : options.isPitchRandomized;\n"
	"		var key = (options != undefined && options.key != undefined) ? options.key : null;\n"
	"\n"
	"		activeSfx = createSfxState(blip, pitchToChromatic(pitch, key), isPitchRandomized);\n"
	"		bitsy.log(\"play blip: \" + activeSfx.frequencies);\n"
	"\n"
	"		bitsy.sound(\n"
	"			channel,\n"
	"			activeSfx.duration * 10, // HACK : mult by 10 is to avoid accidentally turning off early\n"
	"			activeSfx.frequencies.length > 0 ? (activeSfx.frequencies[0] * 100) : 0,\n"
	"			0, // volume\n"
	"			activeSfx.blip.instrument);\n"
	"	};\n"
	"\n"
	"	this.playBlip = playBlip;\n"
	"\n"
	"	this.isBlipPlaying = function() {\n"
	"		return isMusicPausedForBlip; // todo : rename this variable?\n"
	"	};\n"
	"\n"
	"	// todo : should any of this stuff be moved into the tool code?\n"
	"	this.sampleBlip = function(blip, sampleCount) {\n"
	"		var sfx = createSfxState(blip, null, false);\n"
	"\n"
	"		var minFreq = makePitchFrequency({ note: Note.C, octave: Octave[2] });\n"
	"		var maxFreq = makePitchFrequency({ note: Note.B, octave: Octave[5] });\n"
	"\n"
	"		// sample the frequency of the sound\n"
	"		var frequencySamples = [];\n"
	"		for (var i = 0; i < sampleCount; i++) {\n"
	"			if (sfx.frequencies.length > 0) {\n"
	"				var t = Math.floor((i / sampleCount) * sfx.duration);\n"
	"				// get frequency at time\n"
	"				var freq = sfxFrequencyAtTime(sfx, t);\n"
	"				// normalize the sample\n"
	"				freq = freq / (maxFreq - minFreq);\n"
	"\n"
	"				frequencySamples.push(freq);\n"
	"			}\n"
	"			else {\n"
	"				frequencySamples.push(0);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// sample the volume envelope\n"
	"		var amplitudeSamples = [];\n"
	"		for (var i = 0; i < sampleCount; i++) {\n"
	"			var t = Math.floor((i / sampleCount) * sfx.duration);\n"
	"			amplitudeSamples.push(sfxVolumeAtTime(sfx, t) / maxVolume);\n"
	"		}\n"
	"\n"
	"		return {\n"
	"			frequencies: frequencySamples,\n"
	"			amplitudes: amplitudeSamples\n"
	"		};\n"
	"	};\n"
	"}\n";

char* bitsy_js =
	"/* WORLD DATA */\n"
	"var room = {};\n"
	"var tile = {};\n"
	"var sprite = {};\n"
	"var item = {};\n"
	"var dialog = {};\n"
	"var end = {}; // for backwards compatibility\n"
	"var palette = { // start off with a default palette\n"
	"		\"default\" : {\n"
	"			name : \"default\",\n"
	"			colors : [[0,0,0],[255,255,255],[255,255,255]]\n"
	"		}\n"
	"	};\n"
	"var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)\n"
	"var tune = {};\n"
	"var blip = {};\n"
	"var playerId = \"A\";\n"
	"var fontName = defaultFontName;\n"
	"var textDirection = TextDirection.LeftToRight;\n"
	"\n"
	"/* NAME-TO-ID MAPS */\n"
	"var names = {\n"
	"	room : {},\n"
	"	tile : {},\n"
	"	sprite : {},\n"
	"	item : {},\n"
	"	dialog : {},\n"
	"	palette : {},\n"
	"	tune : {},\n"
	"	blip : {},\n"
	"};\n"
	"\n"
	"// todo : this is basically a copy of the one in world.js - can I remove it?\n"
	"function updateNamesFromCurData() {\n"
	"\n"
	"	function createNameMap(objectStore) {\n"
	"		var map = {};\n"
	"\n"
	"		for (id in objectStore) {\n"
	"			if (objectStore[id].name != undefined && objectStore[id].name != null) {\n"
	"				map[objectStore[id].name] = id;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		return map;\n"
	"	}\n"
	"\n"
	"	names.room = createNameMap(room);\n"
	"	names.tile = createNameMap(tile);\n"
	"	names.sprite = createNameMap(sprite);\n"
	"	names.item = createNameMap(item);\n"
	"	names.dialog = createNameMap(dialog);\n"
	"	names.palette = createNameMap(palette);\n"
	"	names.tune = createNameMap(tune);\n"
	"	names.blip = createNameMap(blip);\n"
	"}\n"
	"\n"
	"/* GAME STATE */\n"
	"var state = {}\n"
	"function resetGameState() {\n"
	"	state.room = \"0\";\n"
	"	state.ava = playerId; // avatar appearance override\n"
	"	state.pal = \"0\"; // current palette id\n"
	"	state.tune = \"0\"; // current tune id (\"0\" === off)\n"
	"	state.exits = []; // exits in current room\n"
	"	state.endings = []; // endings in current room\n"
	"}\n"
	"\n"
	"// title helper functions\n"
	"function getTitle() {\n"
	"	return dialog[titleDialogId].src;\n"
	"}\n"
	"function setTitle(titleSrc) {\n"
	"	dialog[titleDialogId] = { src:titleSrc, name:null };\n"
	"}\n"
	"\n"
	"/* FLAGS */\n"
	"var flags = createDefaultFlags();\n"
	"\n"
	"// feature flags for testing purposes\n"
	"var engineFeatureFlags = {\n"
	"	isSoundEnabled : true,\n"
	"	isFontEnabled : true,\n"
	"	isTransitionEnabled : true,\n"
	"	isScriptEnabled : true,\n"
	"	isDialogEnabled : true,\n"
	"	isRendererEnabled : true,\n"
	"};\n"
	"\n"
	"function clearGameData() {\n"
	"	room = {};\n"
	"	tile = {};\n"
	"	sprite = {};\n"
	"	item = {};\n"
	"	dialog = {};\n"
	"	palette = { //start off with a default palette\n"
	"		\"default\" : {\n"
	"			name : \"default\",\n"
	"			colors : [[0,0,0],[255,255,255],[255,255,255]]\n"
	"		}\n"
	"	};\n"
	"	isEnding = false; //todo - correct place for this?\n"
	"	variable = {};\n"
	"\n"
	"	updateNamesFromCurData();\n"
	"\n"
	"	fontName = defaultFontName; // TODO : reset font manager too?\n"
	"	textDirection = TextDirection.LeftToRight;\n"
	"\n"
	"	resetGameState();\n"
	"\n"
	"	isGameLoaded = false;\n"
	"	isGameOver = false;\n"
	"}\n"
	"\n"
	"// engine event hooks for the editor\n"
	"var onInventoryChanged = null;\n"
	"var onVariableChanged = null;\n"
	"var onGameReset = null;\n"
	"var onInitRoom = null;\n"
	"\n"
	"var isPlayerEmbeddedInEditor = false;\n"
	"\n"
	"var renderer;\n"
	"if (engineFeatureFlags.isRendererEnabled) {\n"
	"	renderer = new TileRenderer(\"bitsy\");\n"
	"}\n"
	"\n"
	"var curGameData = null;\n"
	"var curDefaultFontData = null;\n"
	"\n"
	"var isGameLoaded = false;\n"
	"var isGameOver = false;\n"
	"\n"
	"function load_game(gameData, defaultFontData, startWithTitle) {\n"
	"	// bitsy.log(\"game data in: \\n\" + gameData);\n"
	"\n"
	"	curGameData = gameData; //remember the current game (used to reset the game)\n"
	"\n"
	"	if (dialogBuffer) {\n"
	"		dialogBuffer.Reset();\n"
	"	}\n"
	"\n"
	"	if (scriptInterpreter) {\n"
	"		scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?\n"
	"	}\n"
	"\n"
	"	loadWorldFromGameData(gameData);\n"
	"\n"
	"	bitsy.log(\"world loaded\");\n"
	"\n"
	"	if (fontManager && !isPlayerEmbeddedInEditor && defaultFontData) {\n"
	"		bitsy.log(\"load font\");\n"
	"\n"
	"		curDefaultFontData = defaultFontData; // store for resetting game\n"
	"\n"
	"		// todo : consider replacing this with a more general system for requesting resources from the system?\n"
	"		// hack to ensure default font is available\n"
	"		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), defaultFontData);\n"
	"\n"
	"		bitsy.log(\"load font end\");\n"
	"	}\n"
	"\n"
	"	// request text mode\n"
	"	if (flags.TXT_MODE === 1) {\n"
	"		bitsy.textMode(bitsy.TXT_LOREZ);\n"
	"	}\n"
	"	else {\n"
	"		// default to 2x scale for text rendering\n"
	"		bitsy.textMode(bitsy.TXT_HIREZ);\n"
	"	}\n"
	"\n"
	"	if (fontManager && dialogBuffer) {\n"
	"		bitsy.log(\"get font\");\n"
	"\n"
	"		var font = fontManager.Get( fontName );\n"
	"		dialogBuffer.SetFont(font);\n"
	"		dialogRenderer.SetFont(font);\n"
	"\n"
	"		bitsy.log(\"get font end\");\n"
	"	}\n"
	"\n"
	"	if (dialogBuffer) {\n"
	"		// this feels a little silly to me - oh well??\n"
	"		dialogBuffer.SetPixelsPerRow(dialogRenderer.GetPixelsPerRow());\n"
	"	}\n"
	"\n"
	"	setInitialVariables();\n"
	"\n"
	"	bitsy.log(\"ready\");\n"
	"\n"
	"	onready(startWithTitle);\n"
	"\n"
	"	isGameLoaded = true;\n"
	"}\n"
	"\n"
	"function loadWorldFromGameData(gameData) {\n"
	"	bitsy.log(\"load world from game data\");\n"
	"\n"
	"	var world = parseWorld(gameData);\n"
	"\n"
	"	bitsy.log(\"parse world done\");\n"
	"\n"
	"	// move world data into global scope\n"
	"	palette = world.palette;\n"
	"	room = world.room;\n"
	"	tile = world.tile;\n"
	"	sprite = world.sprite;\n"
	"	item = world.item;\n"
	"	dialog = world.dialog;\n"
	"	end = world.end; // back compat endings\n"
	"	variable = world.variable;\n"
	"	fontName = world.fontName;\n"
	"	textDirection = world.textDirection;\n"
	"	tune = world.tune;\n"
	"	blip = world.blip;\n"
	"	flags = world.flags;\n"
	"	names = world.names;\n"
	"\n"
	"	if (renderer) {\n"
	"		renderer.SetDrawings(world.drawings);\n"
	"	}\n"
	"\n"
	"	// find starting room and initialize it\n"
	"	var roomIds = Object.keys(room);\n"
	"\n"
	"	if (player() != undefined && player().room != null && roomIds.indexOf(player().room) != -1) {\n"
	"		// player has valid room\n"
	"		state.room = player().room;\n"
	"	}\n"
	"	else if (roomIds.length > 0) {\n"
	"		// player not in any room! what the heck\n"
	"		state.room = roomIds[0];\n"
	"	}\n"
	"	else {\n"
	"		// uh oh there are no rooms I guess???\n"
	"		state.room = null;\n"
	"	}\n"
	"\n"
	"	if (state.room != null) {\n"
	"		bitsy.log(\"INIT ROOM \" + state.room);\n"
	"		initRoom(state.room);\n"
	"	}\n"
	"}\n"
	"\n"
	"function reset_cur_game() {\n"
	"	if (curGameData == null) {\n"
	"		return; //can't reset if we don't have the game data\n"
	"	}\n"
	"\n"
	"	stopGame();\n"
	"	clearGameData();\n"
	"\n"
	"	if (isPlayerEmbeddedInEditor && onGameReset != null) {\n"
	"		onGameReset();\n"
	"	}\n"
	"}\n"
	"\n"
	"function onready(startWithTitle) {\n"
	"	bitsy.log(\"game ready!\");\n"
	"\n"
	"	if (startWithTitle === undefined || startWithTitle === null) {\n"
	"		startWithTitle = true;\n"
	"	}\n"
	"\n"
	"	if (startWithTitle) { // used by editor \n"
	"		startNarrating(getTitle());\n"
	"	}\n"
	"}\n"
	"\n"
	"function setInitialVariables() {\n"
	"	if (!scriptInterpreter) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	for(id in variable) {\n"
	"		var value = variable[id]; // default to string\n"
	"		if(value === \"true\") {\n"
	"			value = true;\n"
	"		}\n"
	"		else if(value === \"false\") {\n"
	"			value = false;\n"
	"		}\n"
	"		else if(!isNaN(parseFloat(value))) {\n"
	"			value = parseFloat(value);\n"
	"		}\n"
	"		scriptInterpreter.SetVariable(id,value);\n"
	"	}\n"
	"	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );\n"
	"}\n"
	"\n"
	"function getOffset(evt) {\n"
	"	var offset = { x:0, y:0 };\n"
	"\n"
	"	var el = evt.target;\n"
	"	var rect = el.getBoundingClientRect();\n"
	"\n"
	"	offset.x += rect.left + el.scrollLeft;\n"
	"	offset.y += rect.top + el.scrollTop;\n"
	"\n"
	"	offset.x = evt.clientX - offset.x;\n"
	"	offset.y = evt.clientY - offset.y;\n"
	"\n"
	"	return offset;\n"
	"}\n"
	"\n"
	"function stopGame() {\n"
	"	if (soundPlayer) {\n"
	"		soundPlayer.stopTune();\n"
	"	}\n"
	"	bitsy.log(\"stop GAME!\");\n"
	"}\n"
	"\n"
	"function update(dt) {\n"
	"	if (!isGameLoaded) {\n"
	"		load_game(bitsy.getGameData(), bitsy.getFontData());\n"
	"	}\n"
	"\n"
	"	if (state.room == null) {\n"
	"		// in the special case where there is no valid room, end the game\n"
	"		startNarrating( \"\", true /*isEnding*/ );\n"
	"	}\n"
	"\n"
	"	if (!transition || !transition.IsTransitionActive()) {\n"
	"		updateInput();\n"
	"	}\n"
	"\n"
	"	if (transition && transition.IsTransitionActive()) {\n"
	"		// transition animation takes over everything!\n"
	"		transition.UpdateTransition(dt);\n"
	"	}\n"
	"	else {\n"
	"		if (bitsy.graphicsMode() != bitsy.GFX_MAP) {\n"
	"			bitsy.graphicsMode(bitsy.GFX_MAP);\n"
	"		}\n"
	"\n"
	"		if (soundPlayer) {\n"
	"			soundPlayer.update(dt);\n"
	"		}\n"
	"\n"
	"		if (!isNarrating && !isEnding) {\n"
	"			// draw world if game has begun\n"
	"			var didAnimate = updateAnimation(dt);\n"
	"\n"
	"			// test whether player moved so we can redraw just the avatar\n"
	"			playerCurX = player().x;\n"
	"			playerCurY = player().y;\n"
	"			var didPlayerMove = (playerPrevX != playerCurX) || (playerPrevY != playerCurY);\n"
	"\n"
	"			drawRoom(room[state.room], { redrawAnimated: didAnimate, redrawAvatar: didPlayerMove });\n"
	"\n"
	"			// store player's position for next frame\n"
	"			playerPrevX = playerCurX;\n"
	"			playerPrevY = playerCurY;\n"
	"		}\n"
	"		else {\n"
	"			clearRoom();\n"
	"		}\n"
	"\n"
	"		if (dialogBuffer && dialogBuffer.IsActive() && !(soundPlayer && soundPlayer.isBlipPlaying())) {\n"
	"			// bitsy.log(\"update dialog\");\n"
	"			// bitsy.log(\"renderer\");\n"
	"			dialogRenderer.Draw(dialogBuffer, dt);\n"
	"			// bitsy.log(\"buffer\");\n"
	"			dialogBuffer.Update(dt);\n"
	"			// bitsy.log(\"update dialog end\");\n"
	"		}\n"
	"\n"
	"		// keep moving avatar if player holds down button\n"
	"		if ((!dialogBuffer || !dialogBuffer.IsActive()) && !isEnding) {\n"
	"			if (curPlayerDirection != Direction.None) {\n"
	"				playerHoldToMoveTimer -= dt;\n"
	"\n"
	"				if (playerHoldToMoveTimer <= 0) {\n"
	"					movePlayer(curPlayerDirection, false /* isFirstMove */);\n"
	"					playerHoldToMoveTimer = 150;\n"
	"					// playerHoldToMoveTimer = 16; // PERF TEST\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// clean up state if the game is ending\n"
	"	if (isGameOver) {\n"
	"		bitsy.log(\"game over\");\n"
	"		reset_cur_game();\n"
	"	}\n"
	"\n"
	"	return true;\n"
	"}\n"
	"\n"
	"var isAnyButtonHeld = false;\n"
	"var isMenuButtonHeld = false;\n"
	"var isIgnoringInput = false;\n"
	"\n"
	"function isAnyButtonDown() {\n"
	"	return bitsy.button(bitsy.BTN_UP) ||\n"
	"		bitsy.button(bitsy.BTN_DOWN) ||\n"
	"		bitsy.button(bitsy.BTN_LEFT) ||\n"
	"		bitsy.button(bitsy.BTN_RIGHT) ||\n"
	"		bitsy.button(bitsy.BTN_OK);\n"
	"}\n"
	"\n"
	"function updateInput() {\n"
	"	if (dialogBuffer && dialogBuffer.IsActive()) {\n"
	"		if (!(soundPlayer && soundPlayer.isBlipPlaying())) {\n"
	"			if (!isAnyButtonHeld && isAnyButtonDown()) {\n"
	"				/* CONTINUE DIALOG */\n"
	"				if (dialogBuffer.CanContinue()) {\n"
	"					var hasMoreDialog = dialogBuffer.Continue();\n"
	"					if (!hasMoreDialog) {\n"
	"						// ignore currently held keys UNTIL they are released (stops player from insta-moving)\n"
	"						isIgnoringInput = true;\n"
	"						curPlayerDirection = Direction.None;\n"
	"					}\n"
	"				}\n"
	"				else {\n"
	"					dialogBuffer.Skip();\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"	else if (isEnding) {\n"
	"		if (!isAnyButtonHeld && isAnyButtonDown()) {\n"
	"			// tell game to restart\n"
	"			isGameOver = true;\n"
	"		}\n"
	"	}\n"
	"	else if (!isIgnoringInput) {\n"
	"		/* WALK */\n"
	"		var prevPlayerDirection = curPlayerDirection;\n"
	"\n"
	"		if (bitsy.button(bitsy.BTN_UP)) {\n"
	"			curPlayerDirection = Direction.Up;\n"
	"		}\n"
	"		else if (bitsy.button(bitsy.BTN_DOWN)) {\n"
	"			curPlayerDirection = Direction.Down;\n"
	"		}\n"
	"		else if (bitsy.button(bitsy.BTN_LEFT)) {\n"
	"			curPlayerDirection = Direction.Left;\n"
	"		}\n"
	"		else if (bitsy.button(bitsy.BTN_RIGHT)) {\n"
	"			curPlayerDirection = Direction.Right;\n"
	"		}\n"
	"		else {\n"
	"			curPlayerDirection = Direction.None;\n"
	"		}\n"
	"\n"
	"		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {\n"
	"			movePlayer(curPlayerDirection, true /* isFirstMove */);\n"
	"			playerHoldToMoveTimer = 500;\n"
	"			// playerHoldToMoveTimer = 32; // PERF TEST\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if (!isAnyButtonDown()) {\n"
	"		isIgnoringInput = false;\n"
	"	}\n"
	"\n"
	"	// quit when the user releases the restart button\n"
	"	// todo : should I rename it bitsy.BTN_RESTART or bitsy.BTN_QUIT or bitsy.BTN_OFF?\n"
	"	if (isMenuButtonHeld && !bitsy.button(bitsy.BTN_MENU)) {\n"
	"		isGameOver = true;\n"
	"	}\n"
	"\n"
	"	isAnyButtonHeld = isAnyButtonDown();\n"
	"	isMenuButtonHeld = bitsy.button(bitsy.BTN_MENU);\n"
	"}\n"
	"\n"
	"var animationCounter = 0;\n"
	"var animationTime = 400;\n"
	"function updateAnimation(dt) {\n"
	"	animationCounter += dt;\n"
	"	// bitsy.log(\"anim \" + animationCounter);\n"
	"	if (animationCounter >= animationTime) {\n"
	"		// animate sprites\n"
	"		for (id in sprite) {\n"
	"			var spr = sprite[id];\n"
	"			if (spr.animation.isAnimated) {\n"
	"				spr.animation.frameIndex = (spr.animation.frameIndex + 1) % spr.animation.frameCount;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// animate tiles\n"
	"		for (id in tile) {\n"
	"			var til = tile[id];\n"
	"			if (til.animation.isAnimated) {\n"
	"				til.animation.frameIndex = (til.animation.frameIndex + 1) % til.animation.frameCount;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// animate items\n"
	"		for (id in item) {\n"
	"			var itm = item[id];\n"
	"			if (itm.animation.isAnimated) {\n"
	"				itm.animation.frameIndex = (itm.animation.frameIndex + 1) % itm.animation.frameCount;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// reset counter\n"
	"		animationCounter = 0;\n"
	"\n"
	"		// updated animations this frame\n"
	"		return true;\n"
	"	}\n"
	"\n"
	"	// did *not* update animations this frame\n"
	"	return false;\n"
	"}\n"
	"\n"
	"function resetAllAnimations() {\n"
	"	for (id in sprite) {\n"
	"		var spr = sprite[id];\n"
	"		if (spr.animation.isAnimated) {\n"
	"			spr.animation.frameIndex = 0;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	for (id in tile) {\n"
	"		var til = tile[id];\n"
	"		if (til.animation.isAnimated) {\n"
	"			til.animation.frameIndex = 0;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	for (id in item) {\n"
	"		var itm = item[id];\n"
	"		if (itm.animation.isAnimated) {\n"
	"			itm.animation.frameIndex = 0;\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function getSpriteAt(x, y, roomId) {\n"
	"	if (roomId === undefined) {\n"
	"		roomId = state.room;\n"
	"	}\n"
	"\n"
	"	for (id in sprite) {\n"
	"		var spr = sprite[id];\n"
	"		if (spr.room === roomId) {\n"
	"			if (spr.x == x && spr.y == y) {\n"
	"				return id;\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	return null;\n"
	"}\n"
	"\n"
	"var Direction = {\n"
	"	None : -1,\n"
	"	Up : 0,\n"
	"	Down : 1,\n"
	"	Left : 2,\n"
	"	Right : 3\n"
	"};\n"
	"\n"
	"var curPlayerDirection = Direction.None;\n"
	"var playerHoldToMoveTimer = 0;\n"
	"var playerPrevX = 0;\n"
	"var playerPrevY = 0;\n"
	"\n"
	"function movePlayer(direction, isFirstMove) {\n"
	"	didPlayerMove = false;\n"
	"	var roomIds = Object.keys(room);\n"
	"\n"
	"	if (player().room == null || roomIds.indexOf(player().room) < 0) {\n"
	"		return; // player room is missing or invalid.. can't move them!\n"
	"	}\n"
	"\n"
	"	var spr = null;\n"
	"\n"
	"	if (direction == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {\n"
	"		player().x -= 1;\n"
	"	}\n"
	"	else if (direction == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {\n"
	"		player().x += 1;\n"
	"	}\n"
	"	else if (direction == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {\n"
	"		player().y -= 1;\n"
	"	}\n"
	"	else if (direction == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {\n"
	"		player().y += 1;\n"
	"	}\n"
	"\n"
	"	var ext = getExit( player().room, player().x, player().y );\n"
	"	var end = getEnding( player().room, player().x, player().y );\n"
	"	var itmIndex = getItemIndex( player().room, player().x, player().y );\n"
	"\n"
	"	// only play one sound effect per \"turn\"\n"
	"	var blipId = null;\n"
	"\n"
	"	// do items first, because you can pick up an item AND go through a door\n"
	"	if (itmIndex > -1) {\n"
	"		var itm = room[player().room].items[itmIndex];\n"
	"		var itemRoom = player().room;\n"
	"\n"
	"		// play sound on pitck up item\n"
	"		if (item[itm.id].blip != null) {\n"
	"			blipId = item[itm.id].blip;\n"
	"		}\n"
	"\n"
	"		startItemDialog(itm.id, function() {\n"
	"			// remove item from room\n"
	"			room[itemRoom].items.splice(itmIndex, 1);\n"
	"\n"
	"			// update player inventory\n"
	"			if (player().inventory[itm.id]) {\n"
	"				player().inventory[itm.id] += 1;\n"
	"			}\n"
	"			else {\n"
	"				player().inventory[itm.id] = 1;\n"
	"			}\n"
	"\n"
	"			// show inventory change in UI\n"
	"			if (onInventoryChanged != null) {\n"
	"				onInventoryChanged(itm.id);\n"
	"			}\n"
	"		});\n"
	"	}\n"
	"\n"
	"	if (end) {\n"
	"		startEndingDialog(end);\n"
	"	}\n"
	"	else if (ext) {\n"
	"		movePlayerThroughExit(ext);\n"
	"	}\n"
	"	else if (spr) {\n"
	"		// play sound on greet sprite\n"
	"		if (sprite[spr].blip != null) {\n"
	"			blipId = sprite[spr].blip;\n"
	"		}\n"
	"\n"
	"		startSpriteDialog(spr /*spriteId*/);\n"
	"	}\n"
	"\n"
	"	// TODO : maybe add in a future update?\n"
	"	/*\n"
	"	// play sound when player moves (if no other sound selected)\n"
	"	if (isFirstMove && blipId === null && sprite[state.ava].blip != null) {\n"
	"		blipId = sprite[state.ava].blip;\n"
	"		randomizeBlip = true;\n"
	"		blipChannel = bitsy.SOUND2; // play walking sfx *under* the tune melody\n"
	"	}\n"
	"	*/\n"
	"\n"
	"	if (soundPlayer && blipId != null && blip[blipId]) {\n"
	"		soundPlayer.playBlip(blip[blipId]);\n"
	"	}\n"
	"}\n"
	"\n"
	"var transition;\n"
	"if (engineFeatureFlags.isTransitionEnabled) {\n"
	"	transition = new TransitionManager();\n"
	"}\n"
	"\n"
	"function movePlayerThroughExit(ext) {\n"
	"	var GoToDest = function() {\n"
	"		if (transition && ext.transition_effect != null) {\n"
	"			transition.BeginTransition(\n"
	"				player().room,\n"
	"				player().x,\n"
	"				player().y,\n"
	"				ext.dest.room,\n"
	"				ext.dest.x,\n"
	"				ext.dest.y,\n"
	"				ext.transition_effect);\n"
	"\n"
	"			transition.UpdateTransition(0);\n"
	"\n"
	"			transition.OnTransitionComplete(function() {\n"
	"				player().room = ext.dest.room;\n"
	"				player().x = ext.dest.x;\n"
	"				player().y = ext.dest.y;\n"
	"				state.room = ext.dest.room;\n"
	"				initRoom(state.room);\n"
	"			});\n"
	"		}\n"
	"		else {\n"
	"			player().room = ext.dest.room;\n"
	"			player().x = ext.dest.x;\n"
	"			player().y = ext.dest.y;\n"
	"			state.room = ext.dest.room;\n"
	"\n"
	"			initRoom(state.room);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	if (ext.dlg != undefined && ext.dlg != null) {\n"
	"		// TODO : I need to simplify dialog code,\n"
	"		// so I don't have to get the ID and the source str\n"
	"		// every time!\n"
	"		startDialog(\n"
	"			dialog[ext.dlg].src,\n"
	"			ext.dlg,\n"
	"			function(result) {\n"
	"				var isLocked = ext.property && ext.property.locked === true;\n"
	"				if (!isLocked) {\n"
	"					GoToDest();\n"
	"				}\n"
	"			},\n"
	"			ext);\n"
	"	}\n"
	"	else {\n"
	"		GoToDest();\n"
	"	}\n"
	"}\n"
	"\n"
	"/* PALETTE INDICES */\n"
	"var backgroundIndex = 0;\n"
	"var textBackgroundIndex = 1;\n"
	"var textArrowIndex = 2;\n"
	"var textColorIndex = 3;\n"
	"\n"
	"// precalculated rainbow colors\n"
	"var rainbowColorStartIndex = 4;\n"
	"var rainbowColorCount = 10;\n"
	"var rainbowColors = [\n"
	"	[255,0,0],\n"
	"	[255,217,0],\n"
	"	[78,255,0],\n"
	"	[0,255,125],\n"
	"	[0,192,255],\n"
	"	[0,18,255],\n"
	"	[136,0,255],\n"
	"	[255,0,242],\n"
	"	[255,0,138],\n"
	"	[255,0,61],\n"
	"];\n"
	"\n"
	"function updatePaletteWithTileColors(tileColors) {\n"
	"	// the screen background color should match the first tile color\n"
	"	if (tileColors.length > 0) {\n"
	"		var color = tileColors[0];\n"
	"		bitsy.color(backgroundIndex, color[0], color[1], color[2]);\n"
	"	}\n"
	"	else {\n"
	"		// as a fallback, use black as the background\n"
	"		bitsy.log(\"no tile colors!\");\n"
	"		bitsy.color(backgroundIndex, 0, 0, 0);\n"
	"	}\n"
	"\n"
	"	// textbox colors\n"
	"	bitsy.color(textBackgroundIndex, 0, 0, 0); // black\n"
	"	bitsy.color(textArrowIndex, 255, 255, 255); // white\n"
	"	bitsy.color(textColorIndex, 255, 255, 255); // white\n"
	"\n"
	"	// rainbow colors\n"
	"	for (var i = 0; i < rainbowColorCount; i++) {\n"
	"		var color = rainbowColors[i];\n"
	"		bitsy.color(rainbowColorStartIndex + i, color[0], color[1], color[2]);\n"
	"	}\n"
	"\n"
	"	// tile colors\n"
	"	for (var i = 0; i < tileColors.length; i++) {\n"
	"		var color = tileColors[i];\n"
	"		bitsy.color(tileColorStartIndex + i, color[0], color[1], color[2]);\n"
	"	}\n"
	"}\n"
	"\n"
	"function updatePalette(palId) {\n"
	"	state.pal = palId;\n"
	"	var pal = palette[state.pal];\n"
	"	updatePaletteWithTileColors(pal.colors);\n"
	"}\n"
	"\n"
	"function initRoom(roomId) {\n"
	"	bitsy.log(\"init room \" + roomId);\n"
	"\n"
	"	updatePalette(getRoomPal(roomId));\n"
	"\n"
	"	// update avatar appearance\n"
	"	state.ava = (room[roomId].ava != null) ? room[roomId].ava : playerId;\n"
	"\n"
	"	if (renderer) {\n"
	"		renderer.ClearCache();\n"
	"	}\n"
	"\n"
	"	// init exit properties\n"
	"	state.exits = [];\n"
	"	for (var i = 0; i < room[roomId].exits.length; i++) {\n"
	"		var exit = createExitData(\n"
	"			/* x 			*/ room[roomId].exits[i].x,\n"
	"			/* y 			*/ room[roomId].exits[i].y,\n"
	"			/* destRoom 	*/ room[roomId].exits[i].dest.room,\n"
	"			/* destX 		*/ room[roomId].exits[i].dest.x,\n"
	"			/* destY 		*/ room[roomId].exits[i].dest.y,\n"
	"			/* transition 	*/ room[roomId].exits[i].transition_effect,\n"
	"			/* dlg 			*/ room[roomId].exits[i].dlg);\n"
	"		exit.property = { locked: false };\n"
	"\n"
	"		state.exits.push(exit);\n"
	"	}\n"
	"\n"
	"	// init ending properties\n"
	"	state.endings = [];\n"
	"	for (var i = 0; i < room[roomId].endings.length; i++) {\n"
	"		var end = createEndingData(\n"
	"			/* id */ room[roomId].endings[i].id,\n"
	"			/* x  */ room[roomId].endings[i].x,\n"
	"			/* y  */ room[roomId].endings[i].y);\n"
	"		end.property = { locked: false };\n"
	"\n"
	"		state.endings.push(end);\n"
	"	}\n"
	"\n"
	"	if (soundPlayer) {\n"
	"		if (!room[roomId].tune || room[roomId].tune === \"0\" || !tune[room[roomId].tune]) {\n"
	"			// stop music\n"
	"			state.tune = \"0\";\n"
	"			soundPlayer.stopTune();\n"
	"		}\n"
	"		else if (room[roomId].tune != state.tune) {\n"
	"			// start music\n"
	"			state.tune = room[roomId].tune;\n"
	"			soundPlayer.playTune(tune[state.tune]);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	var drawArgs = { redrawAll: true };\n"
	"	drawRoom(room[roomId], drawArgs);\n"
	"\n"
	"	if (onInitRoom) {\n"
	"		onInitRoom(roomId);\n"
	"	}\n"
	"}\n"
	"\n"
	"function getItemIndex( roomId, x, y ) {\n"
	"	for( var i = 0; i < room[roomId].items.length; i++ ) {\n"
	"		var itm = room[roomId].items[i];\n"
	"		if ( itm.x == x && itm.y == y)\n"
	"			return i;\n"
	"	}\n"
	"	return -1;\n"
	"}\n"
	"\n"
	"function getSpriteLeft() { //repetitive?\n"
	"	return getSpriteAt( player().x - 1, player().y );\n"
	"}\n"
	"\n"
	"function getSpriteRight() {\n"
	"	return getSpriteAt( player().x + 1, player().y );\n"
	"}\n"
	"\n"
	"function getSpriteUp() {\n"
	"	return getSpriteAt( player().x, player().y - 1 );\n"
	"}\n"
	"\n"
	"function getSpriteDown() {\n"
	"	return getSpriteAt( player().x, player().y + 1 );\n"
	"}\n"
	"\n"
	"function isWallLeft() {\n"
	"	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );\n"
	"}\n"
	"\n"
	"function isWallRight() {\n"
	"	return (player().x + 1 >= bitsy.MAP_SIZE) || isWall(player().x + 1, player().y);\n"
	"}\n"
	"\n"
	"function isWallUp() {\n"
	"	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );\n"
	"}\n"
	"\n"
	"function isWallDown() {\n"
	"	return (player().y + 1 >= bitsy.MAP_SIZE) || isWall(player().x, player().y + 1);\n"
	"}\n"
	"\n"
	"function isWall(x, y, roomId) {\n"
	"	if (roomId == undefined || roomId == null) {\n"
	"		roomId = state.room;\n"
	"	}\n"
	"\n"
	"	var tileId = getTile(x, y, roomId);\n"
	"	if (tileId === '0') {\n"
	"		return false; // Blank spaces aren't walls, ya doofus\n"
	"	}\n"
	"\n"
	"	if (tile[tileId].isWall === undefined || tile[tileId].isWall === null) {\n"
	"		// No wall-state defined: check room-specific walls\n"
	"		var i = room[roomId].walls.indexOf(getTile(x, y, roomId));\n"
	"		return (i > -1);\n"
	"	}\n"
	"\n"
	"	// Otherwise, use the tile's own wall-state\n"
	"	return tile[tileId].isWall;\n"
	"}\n"
	"\n"
	"function getItem(roomId,x,y) {\n"
	"	for (i in room[roomId].items) {\n"
	"		var item = room[roomId].items[i];\n"
	"		if (x == item.x && y == item.y) {\n"
	"			return item;\n"
	"		}\n"
	"	}\n"
	"	return null;\n"
	"}\n"
	"\n"
	"// todo : roomId isn't useful in these functions anymore! safe to remove?\n"
	"function getExit(roomId, x, y) {\n"
	"	for (i in state.exits) {\n"
	"		var e = state.exits[i];\n"
	"		if (x == e.x && y == e.y) {\n"
	"			return e;\n"
	"		}\n"
	"	}\n"
	"	return null;\n"
	"}\n"
	"\n"
	"function getEnding(roomId, x, y) {\n"
	"	for (i in state.endings) {\n"
	"		var e = state.endings[i];\n"
	"		if (x == e.x && y == e.y) {\n"
	"			return e;\n"
	"		}\n"
	"	}\n"
	"	return null;\n"
	"}\n"
	"\n"
	"function getTile(x, y, roomId) {\n"
	"	// bitsy.log(x + \" \" + y);\n"
	"	var t = getRoom(roomId).tilemap[y][x];\n"
	"	return t;\n"
	"}\n"
	"\n"
	"function player() {\n"
	"	return sprite[playerId];\n"
	"}\n"
	"\n"
	"// Sort of a hack for legacy palette code (when it was just an array)\n"
	"function getPal(id) {\n"
	"	if (palette[id] === undefined) {\n"
	"		id = \"default\";\n"
	"	}\n"
	"\n"
	"	return palette[ id ].colors;\n"
	"}\n"
	"\n"
	"function getRoom(id) {\n"
	"	return room[id === undefined ? state.room : id];\n"
	"}\n"
	"\n"
	"function isSpriteOffstage(id) {\n"
	"	return sprite[id].room == null;\n"
	"}\n"
	"\n"
	"function serializeNote(note, key, useFriendlyName) {\n"
	"	var isSolfa = (key != undefined && key != null);\n"
	"	var noteType = (isSolfa === true) ? Solfa : Note;\n"
	"\n"
	"	if (isSolfa && key.scale.indexOf(note) === -1) {\n"
	"		// no matching note in key\n"
	"		return null;\n"
	"	}\n"
	"\n"
	"	if (isSolfa && useFriendlyName != true) {\n"
	"		for (var name in Solfa) {\n"
	"			if (Solfa[name] === note) {\n"
	"				return name.toLowerCase();\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// no solfa note found\n"
	"		return null;\n"
	"	}\n"
	"\n"
	"	// for a solfa note's \"friendly name\" convert to the chromatic equivalent\n"
	"	if (isSolfa && useFriendlyName === true) {\n"
	"		note = key.notes[note];\n"
	"	}\n"
	"\n"
	"	// from this point on, we know the note we're looking for is chromatic\n"
	"	for (var name in Note) {\n"
	"		if (Note[name] === note) {\n"
	"			name = name.replace(\"_SHARP\", \"#\");\n"
	"			if (useFriendlyName === true && name === \"H\") {\n"
	"				name = \"C\";\n"
	"			}\n"
	"			return name;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// no note found\n"
	"	return symbol;\n"
	"}\n"
	"\n"
	"function serializeOctave(octave) {\n"
	"	for (var symbol in Octave) {\n"
	"		if (Octave[symbol] === octave) {\n"
	"			return symbol;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// default to middle octave\n"
	"	return \"4\";\n"
	"}\n"
	"\n"
	"//TODO this is in progress and doesn't support all features\n"
	"function serializeWorld(skipFonts) {\n"
	"	if (skipFonts === undefined || skipFonts === null) {\n"
	"		skipFonts = false;\n"
	"	}\n"
	"\n"
	"	// update version flags\n"
	"	flags.VER_MAJ = version.major;\n"
	"	flags.VER_MIN = version.minor;\n"
	"\n"
	"	var worldStr = \"\";\n"
	"	/* TITLE */\n"
	"	worldStr += getTitle() + \"\\n\";\n"
	"	worldStr += \"\\n\";\n"
	"	/* VERSION */\n"
	"	worldStr += \"# BITSY VERSION \" + getEngineVersion() + \"\\n\"; // add version as a comment for debugging purposes\n"
	"	if (version.devBuildPhase != \"RELEASE\") {\n"
	"		worldStr += \"# DEVELOPMENT BUILD -- \" + version.devBuildPhase;\n"
	"	}\n"
	"	worldStr += \"\\n\";\n"
	"	/* FLAGS */\n"
	"	for (f in flags) {\n"
	"		worldStr += \"! \" + f + \" \" + flags[f] + \"\\n\";\n"
	"	}\n"
	"	worldStr += \"\\n\"\n"
	"	/* FONT */\n"
	"	if (fontName != defaultFontName) {\n"
	"		worldStr += \"DEFAULT_FONT \" + fontName + \"\\n\";\n"
	"		worldStr += \"\\n\"\n"
	"	}\n"
	"	if (textDirection != TextDirection.LeftToRight) {\n"
	"		worldStr += \"TEXT_DIRECTION \" + textDirection + \"\\n\";\n"
	"		worldStr += \"\\n\"\n"
	"	}\n"
	"	/* PALETTE */\n"
	"	for (id in palette) {\n"
	"		if (id != \"default\") {\n"
	"			worldStr += \"PAL \" + id + \"\\n\";\n"
	"			for (i in getPal(id)) {\n"
	"				for (j in getPal(id)[i]) {\n"
	"					worldStr += getPal(id)[i][j];\n"
	"					if (j < 2) worldStr += \",\";\n"
	"				}\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"			if (palette[id].name != null) {\n"
	"				worldStr += \"NAME \" + palette[id].name + \"\\n\";\n"
	"			}\n"
	"			worldStr += \"\\n\";\n"
	"		}\n"
	"	}\n"
	"	/* ROOM */\n"
	"	for (id in room) {\n"
	"		worldStr += \"ROOM \" + id + \"\\n\";\n"
	"		if ( flags.ROOM_FORMAT == 0 ) {\n"
	"			// old non-comma separated format\n"
	"			for (i in room[id].tilemap) {\n"
	"				for (j in room[id].tilemap[i]) {\n"
	"					worldStr += room[id].tilemap[i][j];	\n"
	"				}\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		else if ( flags.ROOM_FORMAT == 1 ) {\n"
	"			// new comma separated format\n"
	"			for (i in room[id].tilemap) {\n"
	"				for (j in room[id].tilemap[i]) {\n"
	"					worldStr += room[id].tilemap[i][j];\n"
	"					if (j < room[id].tilemap[i].length-1) worldStr += \",\"\n"
	"				}\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (room[id].name != null) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + room[id].name + \"\\n\";\n"
	"		}\n"
	"		if (room[id].walls.length > 0) {\n"
	"			/* WALLS */\n"
	"			worldStr += \"WAL \";\n"
	"			for (j in room[id].walls) {\n"
	"				worldStr += room[id].walls[j];\n"
	"				if (j < room[id].walls.length-1) {\n"
	"					worldStr += \",\";\n"
	"				}\n"
	"			}\n"
	"			worldStr += \"\\n\";\n"
	"		}\n"
	"		if (room[id].items.length > 0) {\n"
	"			/* ITEMS */\n"
	"			for (j in room[id].items) {\n"
	"				var itm = room[id].items[j];\n"
	"				worldStr += \"ITM \" + itm.id + \" \" + itm.x + \",\" + itm.y;\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (room[id].exits.length > 0) {\n"
	"			/* EXITS */\n"
	"			for (j in room[id].exits) {\n"
	"				var e = room[id].exits[j];\n"
	"				if ( isExitValid(e) ) {\n"
	"					worldStr += \"EXT \" + e.x + \",\" + e.y + \" \" + e.dest.room + \" \" + e.dest.x + \",\" + e.dest.y;\n"
	"					if (e.transition_effect != undefined && e.transition_effect != null) {\n"
	"						worldStr += \" FX \" + e.transition_effect;\n"
	"					}\n"
	"					if (e.dlg != undefined && e.dlg != null) {\n"
	"						worldStr += \" DLG \" + e.dlg;\n"
	"					}\n"
	"					worldStr += \"\\n\";\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		if (room[id].endings.length > 0) {\n"
	"			/* ENDINGS */\n"
	"			for (j in room[id].endings) {\n"
	"				var e = room[id].endings[j];\n"
	"				// todo isEndingValid\n"
	"				worldStr += \"END \" + e.id + \" \" + e.x + \",\" + e.y;\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (room[id].pal != null && room[id].pal != \"default\") {\n"
	"			/* PALETTE */\n"
	"			worldStr += \"PAL \" + room[id].pal + \"\\n\";\n"
	"		}\n"
	"		if (room[id].ava != null) {\n"
	"			/* AVATAR SPRITE */\n"
	"			worldStr += \"AVA \" + room[id].ava + \"\\n\";\n"
	"		}\n"
	"		if (room[id].tune != null && room[id].tune != \"0\") {\n"
	"			/* TUNE */\n"
	"			worldStr += \"TUNE \" + room[id].tune + \"\\n\";\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* TILES */\n"
	"	for (id in tile) {\n"
	"		worldStr += \"TIL \" + id + \"\\n\";\n"
	"		worldStr += serializeDrawing( \"TIL_\" + id );\n"
	"		if (tile[id].name != null && tile[id].name != undefined) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + tile[id].name + \"\\n\";\n"
	"		}\n"
	"		if (tile[id].isWall != null && tile[id].isWall != undefined) {\n"
	"			/* WALL */\n"
	"			worldStr += \"WAL \" + tile[id].isWall + \"\\n\";\n"
	"		}\n"
	"		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {\n"
	"			/* COLOR OVERRIDE */\n"
	"			worldStr += \"COL \" + tile[id].col + \"\\n\";\n"
	"		}\n"
	"		if (tile[id].bgc != null && tile[id].bgc != undefined && tile[id].bgc != 0) {\n"
	"			/* BACKGROUND COLOR OVERRIDE */\n"
	"			if (tile[id].bgc < 0) {\n"
	"				// transparent background\n"
	"				worldStr += \"BGC *\\n\";\n"
	"			}\n"
	"			else {\n"
	"				worldStr += \"BGC \" + tile[id].bgc + \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* SPRITES */\n"
	"	for (id in sprite) {\n"
	"		worldStr += \"SPR \" + id + \"\\n\";\n"
	"		worldStr += serializeDrawing( \"SPR_\" + id );\n"
	"		if (sprite[id].name != null && sprite[id].name != undefined) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + sprite[id].name + \"\\n\";\n"
	"		}\n"
	"		if (sprite[id].dlg != null) {\n"
	"			worldStr += \"DLG \" + sprite[id].dlg + \"\\n\";\n"
	"		}\n"
	"		if (sprite[id].room != null) {\n"
	"			/* SPRITE POSITION */\n"
	"			worldStr += \"POS \" + sprite[id].room + \" \" + sprite[id].x + \",\" + sprite[id].y + \"\\n\";\n"
	"		}\n"
	"		if (sprite[id].inventory != null) {\n"
	"			for(itemId in sprite[id].inventory) {\n"
	"				worldStr += \"ITM \" + itemId + \" \" + sprite[id].inventory[itemId] + \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {\n"
	"			/* COLOR OVERRIDE */\n"
	"			worldStr += \"COL \" + sprite[id].col + \"\\n\";\n"
	"		}\n"
	"		if (sprite[id].bgc != null && sprite[id].bgc != undefined && sprite[id].bgc != 0) {\n"
	"			/* BACKGROUND COLOR OVERRIDE */\n"
	"			if (sprite[id].bgc < 0) {\n"
	"				// transparent background\n"
	"				worldStr += \"BGC *\\n\";\n"
	"			}\n"
	"			else {\n"
	"				worldStr += \"BGC \" + sprite[id].bgc + \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (sprite[id].blip != null && sprite[id].blip != undefined) {\n"
	"			/* BLIP */\n"
	"			worldStr += \"BLIP \" + sprite[id].blip + \"\\n\";\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* ITEMS */\n"
	"	for (id in item) {\n"
	"		worldStr += \"ITM \" + id + \"\\n\";\n"
	"		worldStr += serializeDrawing( \"ITM_\" + id );\n"
	"		if (item[id].name != null && item[id].name != undefined) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + item[id].name + \"\\n\";\n"
	"		}\n"
	"		if (item[id].dlg != null) {\n"
	"			worldStr += \"DLG \" + item[id].dlg + \"\\n\";\n"
	"		}\n"
	"		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {\n"
	"			/* COLOR OVERRIDE */\n"
	"			worldStr += \"COL \" + item[id].col + \"\\n\";\n"
	"		}\n"
	"		if (item[id].bgc != null && item[id].bgc != undefined && item[id].bgc != 0) {\n"
	"			/* BACKGROUND COLOR OVERRIDE */\n"
	"			if (item[id].bgc < 0) {\n"
	"				// transparent background\n"
	"				worldStr += \"BGC *\\n\";\n"
	"			}\n"
	"			else {\n"
	"				worldStr += \"BGC \" + item[id].bgc + \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (item[id].blip != null && item[id].blip != undefined) {\n"
	"			/* BLIP */\n"
	"			worldStr += \"BLIP \" + item[id].blip + \"\\n\";\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* DIALOG */\n"
	"	for (id in dialog) {\n"
	"		if (id != titleDialogId) {\n"
	"			worldStr += \"DLG \" + id + \"\\n\";\n"
	"			worldStr += dialog[id].src + \"\\n\";\n"
	"			if (dialog[id].name != null) {\n"
	"				worldStr += \"NAME \" + dialog[id].name + \"\\n\";\n"
	"			}\n"
	"			worldStr += \"\\n\";\n"
	"		}\n"
	"	}\n"
	"	/* ENDINGS (for backwards compability only) */\n"
	"	for (id in end) {\n"
	"		worldStr += \"END \" + id + \"\\n\";\n"
	"		worldStr += end[id].src + \"\\n\";\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* VARIABLES */\n"
	"	for (id in variable) {\n"
	"		worldStr += \"VAR \" + id + \"\\n\";\n"
	"		worldStr += variable[id] + \"\\n\";\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* TUNES */\n"
	"	for (id in tune) {\n"
	"		if (id === \"0\") {\n"
	"			continue;\n"
	"		}\n"
	"\n"
	"		worldStr += \"TUNE \" + id + \"\\n\";\n"
	"		for (var i = 0; i < maxTuneLength && i < tune[id].melody.length; i++) {\n"
	"			// MELODY\n"
	"			for (var j = 0; j < barLength; j++) {\n"
	"				var noteStr = serializeNote(tune[id].melody[i][j].note, tune[id].key);\n"
	"				if (noteStr === null) {\n"
	"					tune[id].melody[i][j].beats = 0;\n"
	"				}\n"
	"				if (tune[id].melody[i][j].beats != 1) {\n"
	"					worldStr += tune[id].melody[i][j].beats;\n"
	"				}\n"
	"				if (tune[id].melody[i][j].beats > 0) {\n"
	"					worldStr += noteStr;\n"
	"				}\n"
	"				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].octave != Octave[4]) {\n"
	"					worldStr += serializeOctave(tune[id].melody[i][j].octave);\n"
	"				}\n"
	"				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].blip != undefined) {\n"
	"					// todo : create constant for the blip separator?\n"
	"					worldStr += \"~\" + tune[id].melody[i][j].blip;\n"
	"				}\n"
	"				if (j < 15) {\n"
	"					worldStr += \",\";\n"
	"				}\n"
	"			}\n"
	"			worldStr += \"\\n\";\n"
	"\n"
	"			// HARMONY\n"
	"			// todo : lots of copy-pasting - I could probably make some helper functions to simplify this\n"
	"			for (var j = 0; j < barLength; j++) {\n"
	"				var noteStr = serializeNote(tune[id].harmony[i][j].note, tune[id].key);\n"
	"				if (noteStr === null) {\n"
	"					tune[id].harmony[i][j].beats = 0;\n"
	"				}\n"
	"				if (tune[id].harmony[i][j].beats != 1) {\n"
	"					worldStr += tune[id].harmony[i][j].beats;\n"
	"				}\n"
	"				if (tune[id].harmony[i][j].beats > 0) {\n"
	"					worldStr += noteStr;\n"
	"				}\n"
	"				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].octave != Octave[4]) {\n"
	"					worldStr += serializeOctave(tune[id].harmony[i][j].octave);\n"
	"				}\n"
	"				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].blip != undefined) {\n"
	"					worldStr += \"~\" + tune[id].harmony[i][j].blip;\n"
	"				}\n"
	"				if (j < 15) {\n"
	"					worldStr += \",\";\n"
	"				}\n"
	"			}\n"
	"			worldStr += \"\\n\";\n"
	"\n"
	"			if (i < (tune[id].melody.length - 1)) {\n"
	"				worldStr += \">\";\n"
	"				worldStr += \"\\n\";\n"
	"			}\n"
	"		}\n"
	"		if (tune[id].name != null) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + tune[id].name + \"\\n\";\n"
	"		}\n"
	"		if (tune[id].key != undefined && tune[id].key != null) {\n"
	"			worldStr += \"KEY \";\n"
	"			for (var i = 0; i < Solfa.COUNT; i++) {\n"
	"				worldStr += serializeNote(tune[id].key.notes[i]);\n"
	"				if (i < Solfa.COUNT - 1) {\n"
	"					worldStr += \",\";\n"
	"				}\n"
	"			}\n"
	"			worldStr += \" \";\n"
	"			for (var i = 0; i < tune[id].key.scale.length; i++) {\n"
	"				worldStr += serializeNote(tune[id].key.scale[i], tune[id].key);\n"
	"				if (i < tune[id].key.scale.length - 1) {\n"
	"					worldStr += \",\";\n"
	"				}\n"
	"			}\n"
	"			worldStr += \"\\n\";\n"
	"		}\n"
	"		worldStr += \"TMP \";\n"
	"		switch (tune[id].tempo) {\n"
	"			case Tempo.SLW:\n"
	"				worldStr += \"SLW\";\n"
	"				break;\n"
	"			case Tempo.MED:\n"
	"				worldStr += \"MED\";\n"
	"				break;\n"
	"			case Tempo.FST:\n"
	"				worldStr += \"FST\";\n"
	"				break;\n"
	"			case Tempo.XFST:\n"
	"				worldStr += \"XFST\";\n"
	"				break;\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"		worldStr += \"SQR \";\n"
	"		switch (tune[id].instrumentA) {\n"
	"			case SquareWave.P8:\n"
	"				worldStr += \"P8\";\n"
	"				break;\n"
	"			case SquareWave.P4:\n"
	"				worldStr += \"P4\";\n"
	"				break;\n"
	"			case SquareWave.P2:\n"
	"				worldStr += \"P2\";\n"
	"				break;\n"
	"		}\n"
	"		worldStr += \" \";\n"
	"		switch (tune[id].instrumentB) {\n"
	"			case SquareWave.P8:\n"
	"				worldStr += \"P8\";\n"
	"				break;\n"
	"			case SquareWave.P4:\n"
	"				worldStr += \"P4\";\n"
	"				break;\n"
	"			case SquareWave.P2:\n"
	"				worldStr += \"P2\";\n"
	"				break;\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"		if (tune[id].key != undefined && tune[id].key != null && tune[id].arpeggioPattern != ArpeggioPattern.OFF) {\n"
	"			switch (tune[id].arpeggioPattern) {\n"
	"				case ArpeggioPattern.UP:\n"
	"					worldStr += \"ARP UP\\n\";\n"
	"					break;\n"
	"				case ArpeggioPattern.DWN:\n"
	"					worldStr += \"ARP DWN\\n\";\n"
	"					break;\n"
	"				case ArpeggioPattern.INT5:\n"
	"					worldStr += \"ARP INT5\\n\";\n"
	"					break;\n"
	"				case ArpeggioPattern.INT8:\n"
	"					worldStr += \"ARP INT8\\n\";\n"
	"					break;\n"
	"			}\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* BLIP */\n"
	"	for (id in blip) {\n"
	"		if (id === \"0\") {\n"
	"			continue;\n"
	"		}\n"
	"\n"
	"		worldStr += \"BLIP \" + id + \"\\n\";\n"
	"		// pitches\n"
	"		if (blip[id].pitchA.beats > 0) {\n"
	"			worldStr += serializeNote(blip[id].pitchA.note);\n"
	"			if (blip[id].pitchA.octave != Octave[4]) {\n"
	"				worldStr += serializeOctave(blip[id].pitchA.octave);\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			worldStr += blip[id].pitchA.beats;\n"
	"		}\n"
	"		worldStr += \",\";\n"
	"		if (blip[id].pitchB.beats > 0) {\n"
	"			worldStr += serializeNote(blip[id].pitchB.note);\n"
	"			if (blip[id].pitchB.octave != Octave[4]) {\n"
	"				worldStr += serializeOctave(blip[id].pitchB.octave);\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			worldStr += blip[id].pitchB.beats;\n"
	"		}\n"
	"		worldStr += \",\";\n"
	"		if (blip[id].pitchC.beats > 0) {\n"
	"			worldStr += serializeNote(blip[id].pitchC.note);\n"
	"			if (blip[id].pitchC.octave != Octave[4]) {\n"
	"				worldStr += serializeOctave(blip[id].pitchC.octave);\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			worldStr += blip[id].pitchC.beats;\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"		if (blip[id].name != null) {\n"
	"			/* NAME */\n"
	"			worldStr += \"NAME \" + blip[id].name + \"\\n\";\n"
	"		}\n"
	"		// envelope\n"
	"		worldStr += \"ENV \" + blip[id].envelope.attack\n"
	"			+ \" \" + blip[id].envelope.decay\n"
	"			+ \" \" + blip[id].envelope.sustain\n"
	"			+ \" \" + blip[id].envelope.length\n"
	"			+ \" \" + blip[id].envelope.release + \"\\n\";\n"
	"		// beat\n"
	"		worldStr += \"BEAT \" + blip[id].beat.time\n"
	"			+ \" \" + blip[id].beat.delay + \"\\n\";\n"
	"		// instrument (square wave type)\n"
	"		worldStr += \"SQR \";\n"
	"		switch (blip[id].instrument) {\n"
	"			case SquareWave.P8:\n"
	"				worldStr += \"P8\";\n"
	"				break;\n"
	"			case SquareWave.P4:\n"
	"				worldStr += \"P4\";\n"
	"				break;\n"
	"			case SquareWave.P2:\n"
	"				worldStr += \"P2\";\n"
	"				break;\n"
	"		}\n"
	"		worldStr += \"\\n\";\n"
	"		// other parameters\n"
	"		if (blip[id].doRepeat === true) {\n"
	"			worldStr += \"RPT 1\\n\";\n"
	"		}\n"
	"		// TODO : consider for future update\n"
	"		// if (blip[id].doSlide === true) {\n"
	"		// 	worldStr += \"SLD 1\\n\";\n"
	"		// }\n"
	"		worldStr += \"\\n\";\n"
	"	}\n"
	"	/* FONT */\n"
	"	// TODO : support multiple fonts\n"
	"	if (fontManager && fontName != defaultFontName && !skipFonts) {\n"
	"		worldStr += fontManager.GetData(fontName);\n"
	"	}\n"
	"\n"
	"	return worldStr;\n"
	"}\n"
	"\n"
	"function serializeDrawing(drwId) {\n"
	"	if (!renderer) {\n"
	"		return \"\";\n"
	"	}\n"
	"\n"
	"	var drawingData = renderer.GetDrawingSource(drwId);\n"
	"	var drwStr = \"\";\n"
	"	for (f in drawingData) {\n"
	"		for (y in drawingData[f]) {\n"
	"			var rowStr = \"\";\n"
	"			for (x in drawingData[f][y]) {\n"
	"				rowStr += drawingData[f][y][x];\n"
	"			}\n"
	"			drwStr += rowStr + \"\\n\";\n"
	"		}\n"
	"		if (f < (drawingData.length-1)) drwStr += \">\\n\";\n"
	"	}\n"
	"	return drwStr;\n"
	"}\n"
	"\n"
	"function isExitValid(e) {\n"
	"	var hasValidStartPos = e.x >= 0 && e.x < bitsy.MAP_SIZE && e.y >= 0 && e.y < bitsy.MAP_SIZE;\n"
	"	var hasDest = e.dest != null;\n"
	"	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < bitsy.MAP_SIZE && e.dest.y >= 0 && e.dest.y < bitsy.MAP_SIZE);\n"
	"	return hasValidStartPos && hasDest && hasValidRoomDest;\n"
	"}\n"
	"\n"
	"function setTile(mapId, x, y, tileId) {\n"
	"	bitsy.set(mapId, (y * bitsy.MAP_SIZE) + x, tileId);\n"
	"}\n"
	"\n"
	"function drawTile(tileId, x, y) {\n"
	"	setTile(bitsy.MAP1, x, y, tileId);\n"
	"}\n"
	"\n"
	"function drawSprite(tileId, x, y) {\n"
	"	setTile(bitsy.MAP2, x, y, tileId);\n"
	"}\n"
	"\n"
	"function drawItem(tileId, x, y) {\n"
	"	setTile(bitsy.MAP2, x, y, tileId);\n"
	"}\n"
	"\n"
	"// var debugLastRoomDrawn = \"0\";\n"
	"\n"
	"function clearRoom() {\n"
	"	var paletteId = \"default\";\n"
	"\n"
	"	if (room === undefined) {\n"
	"		// protect against invalid rooms\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	if (room.pal != null && palette[paletteId] != undefined) {\n"
	"		paletteId = room.pal;\n"
	"	}\n"
	"\n"
	"	// clear background & foreground\n"
	"	bitsy.fill(bitsy.MAP1, 0);\n"
	"	bitsy.fill(bitsy.MAP2, 0);\n"
	"}\n"
	"\n"
	"function drawRoomBackground(room, frameIndex, redrawAnimatedOnly) {\n"
	"	if (!redrawAnimatedOnly) {\n"
	"		// clear background map\n"
	"		bitsy.fill(bitsy.MAP1, 0);\n"
	"	}\n"
	"\n"
	"	// NOTE: interestingly the slowest part of this is iterating over all the tiles, not actually drawing them\n"
	"	for (var y = 0; y < bitsy.MAP_SIZE; y++) {\n"
	"		for (var x = 0; x < bitsy.MAP_SIZE; x++) {\n"
	"			var id = room.tilemap[y][x];\n"
	"\n"
	"			if (id != \"0\" && tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)\n"
	"				id = \"0\";\n"
	"				room.tilemap[y][x] = id;\n"
	"			}\n"
	"\n"
	"			if (id != \"0\" && (!redrawAnimatedOnly || tile[id].animation.isAnimated)) {\n"
	"				drawTile(getTileFrame(tile[id], frameIndex), x, y);\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function drawRoomForeground(room, frameIndex, redrawAnimatedOnly) {\n"
	"	if (!redrawAnimatedOnly) {\n"
	"		// clear foreground map\n"
	"		bitsy.fill(bitsy.MAP2, 0);\n"
	"	}\n"
	"\n"
	"	// draw items\n"
	"	for (var i = 0; i < room.items.length; i++) {\n"
	"		var itm = room.items[i];\n"
	"		if (!redrawAnimatedOnly || item[itm.id].animation.isAnimated) {\n"
	"			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// draw sprites\n"
	"	for (id in sprite) {\n"
	"		var spr = sprite[id];\n"
	"		if (id != playerId && spr.room === room.id && (!redrawAnimatedOnly || spr.animation.isAnimated)) {\n"
	"			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function drawRoomForegroundTile(room, frameIndex, x, y) {\n"
	"	// draw items\n"
	"	for (var i = 0; i < room.items.length; i++) {\n"
	"		var itm = room.items[i];\n"
	"		if (itm.x === x && itm.y === y) {\n"
	"			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// draw sprites\n"
	"	for (id in sprite) {\n"
	"		var spr = sprite[id];\n"
	"		if (id != playerId && spr.room === room.id && spr.x === x && spr.y === y) {\n"
	"			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function drawRoom(room, args) {\n"
	"	if (room === undefined || isNarrating) {\n"
	"		// protect against invalid rooms\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	var redrawAll = args && (args.redrawAll === true);\n"
	"	var redrawAnimated = args && (args.redrawAnimated === true);\n"
	"	var redrawAvatar = args && (args.redrawAvatar === true);\n"
	"	var frameIndex = args ? args.frameIndex : undefined;\n"
	"\n"
	"	// if *only* redrawing the avatar, first clear its previous position\n"
	"	if (redrawAvatar) {\n"
	"		setTile(bitsy.MAP2, playerPrevX, playerPrevY, 0);\n"
	"		// also redraw any sprite or item that might be \"under\" the player (todo: possible perf issue?)\n"
	"		drawRoomForegroundTile(room, frameIndex, playerPrevX, playerPrevY);\n"
	"	}\n"
	"\n"
	"	// draw background & foreground tiles\n"
	"	if (redrawAll || redrawAnimated) {\n"
	"		// draw tiles\n"
	"		drawRoomBackground(room, frameIndex, redrawAnimated);\n"
	"		// draw sprites & items\n"
	"		drawRoomForeground(room, frameIndex, redrawAnimated);\n"
	"	}\n"
	"\n"
	"	// draw the player's avatar at its current position\n"
	"	if ((redrawAll || redrawAnimated || redrawAvatar) && sprite[playerId] && sprite[playerId].room === room.id) {\n"
	"		var spr = sprite[playerId];\n"
	"		var x = spr.x;\n"
	"		var y = spr.y;\n"
	"\n"
	"		// get the avatar override sprite (if there is one)\n"
	"		if (state.ava && state.ava != playerId && sprite[state.ava]) {\n"
	"			spr = sprite[state.ava];\n"
	"		}\n"
	"\n"
	"		drawSprite(getSpriteFrame(spr, frameIndex), x, y);\n"
	"	}\n"
	"}\n"
	"\n"
	"// TODO : remove these get*Image methods\n"
	"function getTileFrame(t, frameIndex) {\n"
	"	if (!renderer) {\n"
	"		return null;\n"
	"	}\n"
	"	return renderer.GetDrawingFrame(t, frameIndex);\n"
	"}\n"
	"\n"
	"function getSpriteFrame(s, frameIndex) {\n"
	"	if (!renderer) {\n"
	"		return null;\n"
	"	}\n"
	"	return renderer.GetDrawingFrame(s, frameIndex);\n"
	"}\n"
	"\n"
	"function getItemFrame(itm, frameIndex) {\n"
	"	if (!renderer) {\n"
	"		return null;\n"
	"	}\n"
	"	return renderer.GetDrawingFrame(itm, frameIndex);\n"
	"}\n"
	"\n"
	"function curDefaultPal() {\n"
	"	return getRoomPal(state.room);\n"
	"}\n"
	"\n"
	"function getRoomPal(roomId) {\n"
	"	var defaultId = \"default\";\n"
	"\n"
	"	if (roomId == null) {\n"
	"		return defaultId;\n"
	"	}\n"
	"	else if (room[roomId].pal != null) {\n"
	"		//a specific palette was chosen\n"
	"		return room[roomId].pal;\n"
	"	}\n"
	"	else {\n"
	"		if (roomId in palette) {\n"
	"			//there is a palette matching the name of the room\n"
	"			return roomId;\n"
	"		}\n"
	"		else {\n"
	"			//use the default palette\n"
	"			return defaultId;\n"
	"		}\n"
	"	}\n"
	"	return defaultId;\n"
	"}\n"
	"\n"
	"var isDialogMode = false;\n"
	"var isNarrating = false;\n"
	"var isEnding = false;\n"
	"\n"
	"var dialogModule;\n"
	"var dialogRenderer;\n"
	"var dialogBuffer;\n"
	"if (engineFeatureFlags.isDialogEnabled) {\n"
	"	dialogModule = new Dialog();\n"
	"	dialogRenderer = dialogModule.CreateRenderer();\n"
	"	dialogBuffer = dialogModule.CreateBuffer();\n"
	"}\n"
	"\n"
	"var fontManager;\n"
	"if (engineFeatureFlags.isFontEnabled) {\n"
	"	fontManager = new FontManager();\n"
	"}\n"
	"\n"
	"// TODO : is this scriptResult thing being used anywhere???\n"
	"function onExitDialog(scriptResult, dialogCallback) {\n"
	"	isDialogMode = false;\n"
	"	bitsy.textbox(false);\n"
	"\n"
	"	if (isNarrating) {\n"
	"		isNarrating = false;\n"
	"\n"
	"		// redraw the room\n"
	"		drawRoom(room[state.room], { redrawAll: true });\n"
	"	}\n"
	"\n"
	"	if (isDialogPreview) {\n"
	"		isDialogPreview = false;\n"
	"\n"
	"		if (onDialogPreviewEnd != null) {\n"
	"			onDialogPreviewEnd();\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if (dialogCallback != undefined && dialogCallback != null) {\n"
	"		dialogCallback(scriptResult);\n"
	"	}\n"
	"\n"
	"	if (soundPlayer) {\n"
	"		soundPlayer.resumeTune();\n"
	"	}\n"
	"}\n"
	"\n"
	"/*\n"
	"TODO\n"
	"- titles and endings should also take advantage of the script pre-compilation if possible??\n"
	"- could there be a namespace collision?\n"
	"- what about dialog NAMEs vs IDs?\n"
	"- what about a special script block separate from DLG?\n"
	"*/\n"
	"function startNarrating(dialogStr, end) {\n"
	"	bitsy.log(\"NARRATE \" + dialogStr);\n"
	"\n"
	"	if(end === undefined) {\n"
	"		end = false;\n"
	"	}\n"
	"\n"
	"	isNarrating = true;\n"
	"	isEnding = end;\n"
	"\n"
	"	if (isEnding && soundPlayer) {\n"
	"		soundPlayer.stopTune();\n"
	"	}\n"
	"\n"
	"	// clear the room tiles before narrating\n"
	"	bitsy.fill(bitsy.MAP1, 0);\n"
	"	bitsy.fill(bitsy.MAP2, 0);\n"
	"\n"
	"	startDialog(dialogStr);\n"
	"}\n"
	"\n"
	"function startEndingDialog(ending) {\n"
	"	isNarrating = true;\n"
	"	isEnding = true;\n"
	"\n"
	"	var endingScriptId = ending.id;\n"
	"	var endingDialogStr = dialog[ending.id].src;\n"
	"\n"
	"	// compatibility with pre-7.0 endings\n"
	"	if (flags.DLG_COMPAT === 1 && end[ending.id]) {\n"
	"		endingScriptId = \"end_compat_\" + ending.id;\n"
	"		endingDialogStr = end[ending.id].src;\n"
	"	}\n"
	"\n"
	"	var tmpTuneId = null;\n"
	"	if (isEnding && soundPlayer) {\n"
	"		tmpTuneId = soundPlayer.getCurTuneId();\n"
	"		soundPlayer.stopTune();\n"
	"	}\n"
	"\n"
	"	startDialog(\n"
	"		endingDialogStr,\n"
	"		endingScriptId,\n"
	"		function() {\n"
	"			var isLocked = ending.property && ending.property.locked === true;\n"
	"			if (isLocked) {\n"
	"				isEnding = false;\n"
	"\n"
	"				// if the ending was cancelled, restart the music\n"
	"				// todo : should it resume from where it started? (right now it starts over)\n"
	"				if (tmpTuneId && soundPlayer && !soundPlayer.isTunePlaying()) {\n"
	"					soundPlayer.playTune(tune[tmpTuneId]);\n"
	"				}\n"
	"			}\n"
	"		},\n"
	"		ending);\n"
	"}\n"
	"\n"
	"function startItemDialog(itemId, dialogCallback) {\n"
	"	var dialogId = item[itemId].dlg;\n"
	"	// bitsy.log(\"START ITEM DIALOG \" + dialogId);\n"
	"	if (dialog[dialogId]) {\n"
	"		var dialogStr = dialog[dialogId].src;\n"
	"		startDialog(dialogStr, dialogId, dialogCallback);\n"
	"	}\n"
	"	else {\n"
	"		dialogCallback();\n"
	"	}\n"
	"}\n"
	"\n"
	"function startSpriteDialog(spriteId) {\n"
	"	var spr = sprite[spriteId];\n"
	"	var dialogId = spr.dlg;\n"
	"\n"
	"	// back compat for when dialog IDs were implicitly the same as sprite IDs\n"
	"	if (flags.DLG_COMPAT === 1 && (dialogId === undefined || dialogId === null)) {\n"
	"		dialogId = spr.id;\n"
	"	}\n"
	"\n"
	"	// bitsy.log(\"START SPRITE DIALOG \" + dialogId);\n"
	"	if (dialog[dialogId]){\n"
	"		var dialogStr = dialog[dialogId].src;\n"
	"		startDialog(dialogStr, dialogId);\n"
	"	}\n"
	"}\n"
	"\n"
	"function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {\n"
	"	bitsy.log(\"START DIALOG\");\n"
	"\n"
	"	if (soundPlayer) {\n"
	"		soundPlayer.pauseTune();\n"
	"	}\n"
	"\n"
	"	if (dialogStr.length <= 0) {\n"
	"		onExitDialog(null, dialogCallback);\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	if (!dialogBuffer) {\n"
	"		bitsy.log(dialogStr);\n"
	"		onExitDialog(null, dialogCallback);\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	if (!scriptInterpreter) {\n"
	"		dialogRenderer.Reset();\n"
	"		dialogRenderer.SetCentered(isNarrating /*centered*/);\n"
	"		dialogBuffer.Reset();\n"
	"		dialogBuffer.AddText(dialogStr);\n"
	"		dialogBuffer.OnDialogEnd(function() {\n"
	"			onExitDialog(null, dialogCallback);\n"
	"		});\n"
	"		bitsy.log(\"dialog start end\");\n"
	"		return;\n"
	"	};\n"
	"\n"
	"	isDialogMode = true;\n"
	"\n"
	"	dialogRenderer.Reset();\n"
	"	dialogRenderer.SetCentered(isNarrating /*centered*/);\n"
	"	dialogBuffer.Reset();\n"
	"	scriptInterpreter.SetDialogBuffer(dialogBuffer);\n"
	"\n"
	"	var onScriptEnd = function(scriptResult) {\n"
	"		dialogBuffer.OnDialogEnd(function() {\n"
	"			onExitDialog(scriptResult, dialogCallback);\n"
	"		});\n"
	"	};\n"
	"\n"
	"	if (scriptId === undefined) { // TODO : what's this for again?\n"
	"		scriptInterpreter.Interpret(dialogStr, onScriptEnd);\n"
	"	}\n"
	"	else {\n"
	"		if (!scriptInterpreter.HasScript(scriptId)) {\n"
	"			scriptInterpreter.Compile(scriptId, dialogStr);\n"
	"		}\n"
	"		// scriptInterpreter.DebugVisualizeScript(scriptId);\n"
	"		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);\n"
	"	}\n"
	"\n"
	"}\n"
	"\n"
	"var isDialogPreview = false;\n"
	"function startPreviewDialog(script, dialogCallback) {\n"
	"	if (!scriptInterpreter || !dialogBuffer) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	isNarrating = true;\n"
	"\n"
	"	isDialogMode = true;\n"
	"\n"
	"	isDialogPreview = true;\n"
	"\n"
	"	dialogRenderer.Reset();\n"
	"	dialogRenderer.SetCentered(true);\n"
	"	dialogBuffer.Reset();\n"
	"	scriptInterpreter.SetDialogBuffer(dialogBuffer);\n"
	"\n"
	"	// TODO : do I really need a seperate callback for this debug mode??\n"
	"	onDialogPreviewEnd = dialogCallback;\n"
	"\n"
	"	var onScriptEndCallback = function(scriptResult) {\n"
	"		dialogBuffer.OnDialogEnd(function() {\n"
	"			onExitDialog(scriptResult, null);\n"
	"		});\n"
	"	};\n"
	"\n"
	"	scriptInterpreter.Eval(script, onScriptEndCallback);\n"
	"}\n"
	"\n"
	"/* NEW SCRIPT STUFF */\n"
	"var scriptModule;\n"
	"var scriptInterpreter;\n"
	"var scriptUtils;\n"
	"// scriptInterpreter.SetDialogBuffer( dialogBuffer );\n"
	"if (engineFeatureFlags.isScriptEnabled) {\n"
	"	bitsy.log(\"init script module\");\n"
	"	scriptModule = new Script();\n"
	"	bitsy.log(\"init interpreter\");\n"
	"	scriptInterpreter = scriptModule.CreateInterpreter();\n"
	"	bitsy.log(\"init utils\");\n"
	"	scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?\n"
	"	bitsy.log(\"init script module end\");\n"
	"}\n"
	"\n"
	"/* SOUND */\n"
	"var soundPlayer;\n"
	"if (engineFeatureFlags.isSoundEnabled) {\n"
	"	soundPlayer = new SoundPlayer();\n"
	"}\n"
	"\n"
	"/* EVENTS */\n"
	"bitsy.loop(update);\n";

char* renderer_js =
	"function TileRenderer(debugName) {\n"
	"bitsy.log(\"!!!!! NEW TILE RENDERER: \" + debugName);\n"
	"\n"
	"var drawingCache = {\n"
	"	source: {},\n"
	"	render: {},\n"
	"};\n"
	"\n"
	"// var debugRenderCount = 0;\n"
	"\n"
	"function createRenderCacheId(drawingId, colorIndex) {\n"
	"	return drawingId + \"_\" + colorIndex;\n"
	"}\n"
	"\n"
	"function renderDrawing(drawing) {\n"
	"	// debugRenderCount++;\n"
	"	// bitsy.log(\"RENDER COUNT \" + debugRenderCount);\n"
	"\n"
	"	var col = drawing.col;\n"
	"	var bgc = drawing.bgc;\n"
	"	var drwId = drawing.drw;\n"
	"	var drawingFrames = drawingCache.source[drwId];\n"
	"\n"
	"	// initialize render cache entry\n"
	"	var cacheId = createRenderCacheId(drwId, col);\n"
	"	if (drawingCache.render[cacheId] === undefined) {\n"
	"		// initialize array of frames for drawing\n"
	"		drawingCache.render[cacheId] = [];\n"
	"	}\n"
	"\n"
	"	for (var i = 0; i < drawingFrames.length; i++) {\n"
	"		var frameData = drawingFrames[i];\n"
	"		var frameTileId = renderTileFromDrawingData(frameData, col, bgc);\n"
	"\n"
	"		if (drawing.id === \"b\") {\n"
	"			bitsy.log(\"RENDER FRAME \" + i + \" drawing: \" + drawing.id + \" tile: \" + frameTileId);\n"
	"		}\n"
	"\n"
	"		drawingCache.render[cacheId].push(frameTileId);\n"
	"	}\n"
	"}\n"
	"\n"
	"function renderTileFromDrawingData(drawingData, col, bgc) {\n"
	"	var tileId = bitsy.tile();\n"
	"\n"
	"	var backgroundColor = tileColorStartIndex + bgc;\n"
	"	var foregroundColor = tileColorStartIndex + col;\n"
	"\n"
	"	bitsy.fill(tileId, backgroundColor);\n"
	"\n"
	"	for (var y = 0; y < bitsy.TILE_SIZE; y++) {\n"
	"		if (tileId === 4) {\n"
	"			bitsy.log(\">> \" + drawingData[y]);\n"
	"		}\n"
	"\n"
	"		for (var x = 0; x < bitsy.TILE_SIZE; x++) {\n"
	"			var px = drawingData[y][x];\n"
	"			if (px === 1) {\n"
	"				if (tileId === 4) {\n"
	"					bitsy.log(\"! set pixel: \" + tileId + \": \" + x + \",\" + y + \" \" + foregroundColor);\n"
	"				}\n"
	"				bitsy.set(tileId, (y * bitsy.TILE_SIZE) + x, foregroundColor);\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	return tileId;\n"
	"}\n"
	"\n"
	"// TODO : move into core\n"
	"function undefinedOrNull(x) {\n"
	"	return x === undefined || x === null;\n"
	"}\n"
	"\n"
	"function isDrawingRendered(drawing) {\n"
	"	var cacheId = createRenderCacheId(drawing.drw, drawing.col);\n"
	"	return drawingCache.render[cacheId] != undefined;\n"
	"}\n"
	"\n"
	"function getRenderedDrawingFrames(drawing) {\n"
	"	var cacheId = createRenderCacheId(drawing.drw, drawing.col);\n"
	"	return drawingCache.render[cacheId];\n"
	"}\n"
	"\n"
	"function getDrawingFrameTileId(drawing, frameOverride) {\n"
	"	var frameIndex = 0;\n"
	"\n"
	"	if (drawing != null && drawing.animation.isAnimated) {\n"
	"		if (frameOverride != undefined && frameOverride != null) {\n"
	"			frameIndex = frameOverride;\n"
	"		}\n"
	"		else {\n"
	"			frameIndex = drawing.animation.frameIndex;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	var tileId = getRenderedDrawingFrames(drawing)[frameIndex];\n"
	"\n"
	"	if (drawing.id === \"b\") {\n"
	"		bitsy.log(\"GET TILE ID \" + drawing.id + \" - \" + tileId);\n"
	"	}\n"
	"\n"
	"	return tileId;\n"
	"}\n"
	"\n"
	"function getOrRenderDrawingFrame(drawing, frameOverride) {\n"
	"	if (drawing.id === \"b\") {\n"
	"		bitsy.log(\"frame render: \" + drawing.type + \" \" + drawing.id + \" f:\" + frameOverride);\n"
	"	}\n"
	"\n"
	"	if (!isDrawingRendered(drawing)) {\n"
	"		bitsy.log(\"frame render: doesn't exist \" + drawing.id);\n"
	"		renderDrawing(drawing);\n"
	"	}\n"
	"\n"
	"	return getDrawingFrameTileId(drawing, frameOverride);\n"
	"}\n"
	"\n"
	"function deleteRenders(drawingId) {\n"
	"	for (var cacheId in drawingCache.render) {\n"
	"		if (cacheId.indexOf(drawingId) === 0) {\n"
	"			var tiles = drawingCache.render[cacheId];\n"
	"			for (var i = 0; i < tiles.length; i++) {\n"
	"				bitsy.delete(tiles[i]);\n"
	"			}\n"
	"			delete drawingCache.render[cacheId];\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"/* PUBLIC INTERFACE */\n"
	"this.GetDrawingFrame = getOrRenderDrawingFrame;\n"
	"\n"
	"// todo : leave individual get and set stuff for now - should I remove later?\n"
	"// todo : better name for function?\n"
	"this.SetDrawings = function(drawingSource) {\n"
	"	drawingCache.source = drawingSource;\n"
	"	// need to reset entire render cache when all the drawings are changed\n"
	"	drawingCache.render = {};\n"
	"};\n"
	"\n"
	"this.SetDrawingSource = function(drawingId, drawingData) {\n"
	"	deleteRenders(drawingId);\n"
	"	drawingCache.source[drawingId] = drawingData;\n"
	"};\n"
	"\n"
	"this.GetDrawingSource = function(drawingId) {\n"
	"	return drawingCache.source[drawingId];\n"
	"};\n"
	"\n"
	"this.GetFrameCount = function(drawingId) {\n"
	"	return drawingCache.source[drawingId].length;\n"
	"};\n"
	"\n"
	"// todo : forceReset option is hacky?\n"
	"this.ClearCache = function(forceReset) {\n"
	"	if (forceReset === undefined || forceReset === true) {\n"
	"		// delete all tiles from system memory before clearing the cache\n"
	"		for (var cacheId in drawingCache.render) {\n"
	"			var tiles = drawingCache.render[cacheId];\n"
	"			for (var i = 0; i < tiles.length; i++) {\n"
	"				bitsy.delete(tiles[i]);\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	drawingCache.render = {};\n"
	"};\n"
	"\n"
	"this.deleteDrawing = deleteRenders;\n"
	"\n"
	"} // Renderer()\n";

char* font_js =
	"/*\n"
	"TODO:\n"
	"- can I simplify this more now that I've removed the external resources stuff?\n"
	"*/\n"
	"\n"
	"function FontManager(packagedFontNames) {\n"
	"\n"
	"var self = this;\n"
	"\n"
	"var fontExtension = \".bitsyfont\";\n"
	"this.GetExtension = function() {\n"
	"	return fontExtension;\n"
	"}\n"
	"\n"
	"// place to store font data\n"
	"var fontResources = {};\n"
	"\n"
	"// load fonts from the editor\n"
	"if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0\n"
	"		&& Resources != undefined && Resources != null) {\n"
	"\n"
	"	for (var i = 0; i < packagedFontNames.length; i++) {\n"
	"		var filename = packagedFontNames[i];\n"
	"		fontResources[filename] = Resources[filename];\n"
	"	}\n"
	"}\n"
	"\n"
	"// manually add resource\n"
	"this.AddResource = function(filename, fontdata) {\n"
	"	fontResources[filename] = fontdata;\n"
	"}\n"
	"\n"
	"this.ContainsResource = function(filename) {\n"
	"	return fontResources[filename] != null;\n"
	"}\n"
	"\n"
	"function GetData(fontName) {\n"
	"	return fontResources[fontName + fontExtension];\n"
	"}\n"
	"this.GetData = GetData;\n"
	"\n"
	"function Create(fontData) {\n"
	"	return new Font(fontData);\n"
	"}\n"
	"this.Create = Create;\n"
	"\n"
	"this.Get = function(fontName) {\n"
	"	var fontData = self.GetData(fontName);\n"
	"	return self.Create(fontData);\n"
	"}\n"
	"\n"
	"function Font(fontData) {\n"
	"	bitsy.log(\"create font\");\n"
	"\n"
	"	var name = \"unknown\";\n"
	"	var width = 6; // default size so if you have NO font or an invalid font it displays boxes\n"
	"	var height = 8;\n"
	"	var chardata = {};\n"
	"\n"
	"	// create invalid char data at default size in case the font is missing\n"
	"	var invalidCharData = {};\n"
	"	updateInvalidCharData();\n"
	"\n"
	"	this.getName = function() {\n"
	"		return name;\n"
	"	}\n"
	"\n"
	"	this.getData = function() {\n"
	"		return chardata;\n"
	"	}\n"
	"\n"
	"	this.getWidth = function() {\n"
	"		return width;\n"
	"	}\n"
	"\n"
	"	this.getHeight = function() {\n"
	"		return height;\n"
	"	}\n"
	"\n"
	"	this.hasChar = function(char) {\n"
	"		var codepoint = char.charCodeAt(0);\n"
	"		return chardata[codepoint] != null;\n"
	"	}\n"
	"\n"
	"	this.getChar = function(char) {\n"
	"\n"
	"		var codepoint = char.charCodeAt(0);\n"
	"\n"
	"		if (chardata[codepoint] != null) {\n"
	"			return chardata[codepoint];\n"
	"		}\n"
	"		else {\n"
	"			return invalidCharData;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.allCharCodes = function() {\n"
	"		var codeList = [];\n"
	"		for (var code in chardata) {\n"
	"			codeList.push(code);\n"
	"		}\n"
	"		return codeList;\n"
	"	}\n"
	"\n"
	"	function createCharData() {\n"
	"		return { \n"
	"			width: width,\n"
	"			height: height,\n"
	"			offset: {\n"
	"				x: 0,\n"
	"				y: 0\n"
	"			},\n"
	"			spacing: width,\n"
	"			data: [],\n"
	"		};\n"
	"	}\n"
	"\n"
	"	function updateInvalidCharData() {\n"
	"		invalidCharData = createCharData();\n"
	"		for (var y = 0; y < height; y++) {\n"
	"			for (var x = 0; x < width; x++) {\n"
	"				if (x < width-1 && y < height-1) {\n"
	"					invalidCharData.data.push(1);\n"
	"				}\n"
	"				else {\n"
	"					invalidCharData.data.push(0);\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	function parseFont(fontData) {\n"
	"		if (fontData == null) {\n"
	"			return;\n"
	"		}\n"
	"\n"
	"		bitsy.log(\"split font lines\");\n"
	"		// NOTE: this is where we run out of memory - split creates a lot of memory issues\n"
	"		// var lines = fontData.split(\"\\n\");\n"
	"		bitsy.log(\"after split lines\");\n"
	"\n"
	"		var isReadingChar = false;\n"
	"		var isReadingCharProperties = false;\n"
	"		var curCharLineCount = 0;\n"
	"		var curCharCode = 0;\n"
	"\n"
	"		var lineStart = 0;\n"
	"		var lineEnd = fontData.indexOf(\"\\n\", lineStart) != -1\n"
	"			? fontData.indexOf(\"\\n\", lineStart)\n"
	"			: fontData.length;\n"
	"\n"
	"		// for (var i = 0; i < lines.length; i++) {\n"
	"		// 	var line = lines[i];\n"
	"		while (lineStart < fontData.length) {\n"
	"			var line = fontData.substring(lineStart, lineEnd);\n"
	"			// bitsy.log(\"parse font xx \" + line);\n"
	"\n"
	"			if (line[0] === \"#\") {\n"
	"				// skip comment lines\n"
	"			}\n"
	"			else if (!isReadingChar) {\n"
	"				// READING NON CHARACTER DATA LINE\n"
	"				var args = line.split(\" \");\n"
	"				if (args[0] == \"FONT\") {\n"
	"					name = args[1];\n"
	"				}\n"
	"				else if (args[0] == \"SIZE\") {\n"
	"					width = parseInt(args[1]);\n"
	"					height = parseInt(args[2]);\n"
	"				}\n"
	"				else if (args[0] == \"CHAR\") {\n"
	"					isReadingChar = true;\n"
	"					isReadingCharProperties = true;\n"
	"\n"
	"					curCharLineCount = 0;\n"
	"					curCharCode = parseInt(args[1]);\n"
	"					chardata[curCharCode] = createCharData();\n"
	"				}\n"
	"			}\n"
	"			else {\n"
	"				// CHAR PROPERTIES\n"
	"				if (isReadingCharProperties) {\n"
	"					var args = line.split(\" \");\n"
	"					if (args[0].indexOf(\"CHAR_\") == 0) { // Sub-properties start with \"CHAR_\"\n"
	"						if (args[0] == \"CHAR_SIZE\") {\n"
	"							// Custom character size - overrides the default character size for the font\n"
	"							chardata[curCharCode].width = parseInt(args[1]);\n"
	"							chardata[curCharCode].height = parseInt(args[2]);\n"
	"							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first\n"
	"						}\n"
	"						else if (args[0] == \"CHAR_OFFSET\") {\n"
	"							// Character offset - shift the origin of the character on the X or Y axis\n"
	"							chardata[curCharCode].offset.x = parseInt(args[1]);\n"
	"							chardata[curCharCode].offset.y = parseInt(args[2]);\n"
	"						}\n"
	"						else if (args[0] == \"CHAR_SPACING\") {\n"
	"							// Character spacing:\n"
	"							// specify total horizontal space taken up by the character\n"
	"							// lets chars take up more or less space on a line than its bitmap does\n"
	"							chardata[curCharCode].spacing = parseInt(args[1]);\n"
	"						}\n"
	"					}\n"
	"					else {\n"
	"						isReadingCharProperties = false;\n"
	"					}\n"
	"				}\n"
	"\n"
	"				// CHAR DATA\n"
	"				if (!isReadingCharProperties) {\n"
	"					// READING CHARACTER DATA LINE\n"
	"					for (var j = 0; j < chardata[curCharCode].width; j++)\n"
	"					{\n"
	"						chardata[curCharCode].data.push( parseInt(line[j]) );\n"
	"					}\n"
	"\n"
	"					curCharLineCount++;\n"
	"					if (curCharLineCount >= chardata[curCharCode].height) {\n"
	"						isReadingChar = false;\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"\n"
	"			lineStart = lineEnd + 1;\n"
	"			lineEnd = fontData.indexOf(\"\\n\", lineStart) != -1\n"
	"				? fontData.indexOf(\"\\n\", lineStart)\n"
	"				: fontData.length;\n"
	"		}\n"
	"\n"
	"		// re-init invalid character box at the actual font size once it's loaded\n"
	"		updateInvalidCharData();\n"
	"	}\n"
	"\n"
	"	bitsy.log(\"parse font\");\n"
	"	parseFont(fontData);\n"
	"\n"
	"	bitsy.log(\"create font\");\n"
	"}\n"
	"\n"
	"} // FontManager\n"
	"\n";

#endif